"""
This type stub file was generated by pyright.
"""

import ssl
import sys
from logging import FileHandler, Handler, LogRecord
from socket import SocketType
from typing import Any, Callable, Dict, List, Optional, Tuple, Union
from os import PathLike

if sys.version_info >= (3, 7):
    ...
else:
    ...
_SocketKind = int
if sys.version_info >= (3, 6):
    _Path = Union[str, PathLike[str]]
else:
    ...
DEFAULT_TCP_LOGGING_PORT: int
DEFAULT_UDP_LOGGING_PORT: int
DEFAULT_HTTP_LOGGING_PORT: int
DEFAULT_SOAP_LOGGING_PORT: int
SYSLOG_UDP_PORT: int
SYSLOG_TCP_PORT: int
class WatchedFileHandler(FileHandler):
    dev: int
    ino: int
    def __init__(self, filename: _Path, mode: str = ..., encoding: Optional[str] = ..., delay: bool = ...) -> None:
        ...
    
    def _statstream(self) -> None:
        ...
    


if sys.version_info >= (3, ):
    class BaseRotatingHandler(FileHandler):
        terminator: str
        namer: Optional[Callable[[str], str]]
        rotator: Optional[Callable[[str, str], None]]
        def __init__(self, filename: _Path, mode: str, encoding: Optional[str] = ..., delay: bool = ...) -> None:
            ...
        
        def rotation_filename(self, default_name: str) -> None:
            ...
        
        def rotate(self, source: str, dest: str) -> None:
            ...
        
    
    
if sys.version_info >= (3, ):
    class RotatingFileHandler(BaseRotatingHandler):
        def __init__(self, filename: _Path, mode: str = ..., maxBytes: int = ..., backupCount: int = ..., encoding: Optional[str] = ..., delay: bool = ...) -> None:
            ...
        
        def doRollover(self) -> None:
            ...
        
    
    
else:
    ...
if sys.version_info >= (3, ):
    class TimedRotatingFileHandler(BaseRotatingHandler):
        def doRollover(self) -> None:
            ...
        
    
    
else:
    ...
class SocketHandler(Handler):
    retryStart: float
    retryFactor: float
    retryMax: float
    if sys.version_info >= (3, 4):
        def __init__(self, host: str, port: Optional[int]) -> None:
            ...
        
    else:
        ...
    def makeSocket(self) -> SocketType:
        ...
    
    def makePickle(self, record: LogRecord) -> bytes:
        ...
    
    def send(self, packet: bytes) -> None:
        ...
    
    def createSocket(self) -> None:
        ...
    


class DatagramHandler(SocketHandler):
    ...


class SysLogHandler(Handler):
    LOG_ALERT: int
    LOG_CRIT: int
    LOG_DEBUG: int
    LOG_EMERG: int
    LOG_ERR: int
    LOG_INFO: int
    LOG_NOTICE: int
    LOG_WARNING: int
    LOG_AUTH: int
    LOG_AUTHPRIV: int
    LOG_CRON: int
    LOG_DAEMON: int
    LOG_FTP: int
    LOG_KERN: int
    LOG_LPR: int
    LOG_MAIL: int
    LOG_NEWS: int
    LOG_SYSLOG: int
    LOG_USER: int
    LOG_UUCP: int
    LOG_LOCAL0: int
    LOG_LOCAL1: int
    LOG_LOCAL2: int
    LOG_LOCAL3: int
    LOG_LOCAL4: int
    LOG_LOCAL5: int
    LOG_LOCAL6: int
    LOG_LOCAL7: int
    def __init__(self, address: Union[Tuple[str, int], str] = ..., facility: int = ..., socktype: _SocketKind = ...) -> None:
        ...
    
    def encodePriority(self, facility: Union[int, str], priority: Union[int, str]) -> int:
        ...
    
    def mapPriority(self, levelName: str) -> str:
        ...
    


class NTEventLogHandler(Handler):
    def __init__(self, appname: str, dllname: str = ..., logtype: str = ...) -> None:
        ...
    
    def getEventCategory(self, record: LogRecord) -> int:
        ...
    
    def getEventType(self, record: LogRecord) -> int:
        ...
    
    def getMessageID(self, record: LogRecord) -> int:
        ...
    


class SMTPHandler(Handler):
    if sys.version_info >= (3, ):
        def __init__(self, mailhost: Union[str, Tuple[str, int]], fromaddr: str, toaddrs: List[str], subject: str, credentials: Optional[Tuple[str, str]] = ..., secure: Union[Tuple[str], Tuple[str, str], None] = ..., timeout: float = ...) -> None:
            ...
        
    else:
        ...
    def getSubject(self, record: LogRecord) -> str:
        ...
    


class BufferingHandler(Handler):
    buffer: List[LogRecord]
    def __init__(self, capacity: int) -> None:
        ...
    
    def shouldFlush(self, record: LogRecord) -> bool:
        ...
    


class MemoryHandler(BufferingHandler):
    def __init__(self, capacity: int, flushLevel: int = ..., target: Optional[Handler] = ...) -> None:
        ...
    
    def setTarget(self, target: Handler) -> None:
        ...
    


class HTTPHandler(Handler):
    if sys.version_info >= (3, 5):
        def __init__(self, host: str, url: str, method: str = ..., secure: bool = ..., credentials: Optional[Tuple[str, str]] = ..., context: Optional[ssl.SSLContext] = ...) -> None:
            ...
        
    else:
        ...
    def mapLogRecord(self, record: LogRecord) -> Dict[str, Any]:
        ...
    


if sys.version_info >= (3, ):
    class QueueHandler(Handler):
        def prepare(self, record: LogRecord) -> Any:
            ...
        
        def enqueue(self, record: LogRecord) -> None:
            ...
        
    
    
    class QueueListener:
        def dequeue(self, block: bool) -> LogRecord:
            ...
        
        def prepare(self, record: LogRecord) -> Any:
            ...
        
        def start(self) -> None:
            ...
        
        def stop(self) -> None:
            ...
        
        def enqueue_sentinel(self) -> None:
            ...
        
    
    
