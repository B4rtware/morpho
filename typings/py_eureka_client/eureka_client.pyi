"""
This type stub file was generated by pyright.
"""

import atexit
from threading import RLock
from urllib.error import HTTPError
from py_eureka_client.__logger__ import get_logger
from typing import Any, Callable, Literal, Optional, Sequence, Union, Dict

INSTANCE_STATUS_UP = "UP"
INSTANCE_STATUS_DOWN = "DOWN"
INSTANCE_STATUS_STARTING = "STARTING"
INSTANCE_STATUS_OUT_OF_SERVICE = "OUT_OF_SERVICE"
INSTANCE_STATUS_UNKNOWN = "UNKNOWN"
ACTION_TYPE_ADDED = "ADDED"
ACTION_TYPE_MODIFIED = "MODIFIED"
ACTION_TYPE_DELETED = "DELETED"
HA_STRATEGY_RANDOM = 1
HA_STRATEGY_STICK = 2
HA_STRATEGY_OTHER = 3

_DEFAULT_TIME_OUT = 5

_DEFAULT_EUREKA_SERVER_URL = "http://127.0.0.1:8761/eureka/"

_RENEWAL_INTERVAL_IN_SECS = 30
_DURATION_IN_SECS = 90
_DEFAULT_DATA_CENTER_INFO = "MyOwn"
_DEFAULT_DATA_CENTER_INFO_CLASS = "com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo"

_DEFAULT_INSTNACE_SECURE_PORT = 9443
_DEFAULT_INSTNACE_PORT = 9090

class Applications:
    def __init__(self, apps__hashcode: str=..., versions__delta: str=..., applications: Optional[Sequence[Application]] = ...):
        self.apps__hashcode: str = ...
        self.versions__delta: str = ...
    
    @property
    def appsHashcode(self) -> str: ...
    @property
    def applications(self) -> Sequence[Application]: ...
    @property
    def versionsDelta(self) -> str: ...
    def add_application(self, application: Application) -> None: ...
    def get_application(self, app_name: str) -> Application: ...
    


class Application:
    def __init__(self, name: str="", instances: Optional[Sequence[Instance]] = ...):
        self.name: str
    
    @property
    def instances(self) -> Sequence[Instance]: ...
    @property
    def up_instances(self) -> Sequence[Instance]: ...
    def get_instance(self, instance_id: str) -> Instance: ...
    def add_instance(self, instance: Instance) -> None: ...
    def update_instance(self, instance: Instance) -> None: ...
    def remove_instance(self, instance: Instance) -> None: ...
    


class LeaseInfo:
    def __init__(self, renewalIntervalInSecs: int= _RENEWAL_INTERVAL_IN_SECS, durationInSecs: int=_DURATION_IN_SECS, registrationTimestamp: int=0, lastRenewalTimestamp: int=0, renewalTimestamp: int=0, evictionTimestamp: int=0, serviceUpTimestamp: int=0) -> None:
        self.renewalIntervalInSecs: int
        self.durationInSecs: int
        self.registrationTimestamp: int
        self.lastRenewalTimestamp: int
        self.renewalTimestamp: int
        self.evictionTimestamp: int
        self.serviceUpTimestamp: int
    


class DataCenterInfo:
    def __init__(self, name: str=_DEFAULT_DATA_CENTER_INFO, className: str=_DEFAULT_DATA_CENTER_INFO_CLASS):
        self.name: str
        self.className: str
    


class PortWrapper:
    def __init__(self, port: int=0, enabled: bool=False):
        self.port: int
        self.enabled: bool
    


class Instance:
    def __init__(self, instanceId: str="", sid: str="", app: str="", appGroupName: str="", ipAddr: str="", port: PortWrapper=PortWrapper(port=_DEFAULT_INSTNACE_PORT, enabled=True), securePort: PortWrapper=PortWrapper(port=_DEFAULT_INSTNACE_SECURE_PORT, enabled=False), homePageUrl: str="", statusPageUrl: str="", healthCheckUrl: str="", secureHealthCheckUrl: str="", vipAddress: str="", secureVipAddress: str="", countryId: int=1, dataCenterInfo: DataCenterInfo=DataCenterInfo(), hostName: str="", status: Union[INSTANCE_STATUS_UP, INSTANCE_STATUS_DOWN, INSTANCE_STATUS_STARTING, INSTANCE_STATUS_OUT_OF_SERVICE, INSTANCE_STATUS_UNKNOWN, Literal[""]]="", overriddenstatus: Union[INSTANCE_STATUS_UP, INSTANCE_STATUS_DOWN, INSTANCE_STATUS_STARTING, INSTANCE_STATUS_OUT_OF_SERVICE, INSTANCE_STATUS_UNKNOWN, Literal[""]]="", leaseInfo: LeaseInfo=LeaseInfo(), isCoordinatingDiscoveryServer: bool=False, metadata: Optional[Dict[str, Any]]=None, lastUpdatedTimestamp: int=0, lastDirtyTimestamp: int=0, actionType: Union[ACTION_TYPE_ADDED, ACTION_TYPE_DELETED, ACTION_TYPE_MODIFIED]=ACTION_TYPE_ADDED, asgName: str="") -> None:
        self.instanceId: str
        self.sid: str
        self.app: str
        self.appGroupName: str
        self.ipAddr: str
        self.port: PortWrapper
        self.securePort: PortWrapper
        self.homePageUrl: str
        self.statusPageUrl: str
        self.healthCheckUrl: str
        self.secureHealthCheckUrl: str
        self.vipAddress: str
        self.secureVipAddress: str
        self.countryId: int
        self.dataCenterInfo: DataCenterInfo
        self.hostName: str
        self.status: Union[INSTANCE_STATUS_UP, INSTANCE_STATUS_DOWN, INSTANCE_STATUS_STARTING, INSTANCE_STATUS_OUT_OF_SERVICE, INSTANCE_STATUS_UNKNOWN, Literal[""]]
        self.overriddenstatus: Union[INSTANCE_STATUS_UP, INSTANCE_STATUS_DOWN, INSTANCE_STATUS_STARTING, INSTANCE_STATUS_OUT_OF_SERVICE, INSTANCE_STATUS_UNKNOWN, Literal[""]]
        self.leaseInfo: LeaseInfo
        self.isCoordinatingDiscoveryServer: bool
        self.metadata: Optional[Dict[str, Any]]
        self.lastUpdatedTimestamp: int
        self.lastDirtyTimestamp: int
        self.actionType: Union[ACTION_TYPE_ADDED, ACTION_TYPE_DELETED, ACTION_TYPE_MODIFIED]
        self.asgName: str
        
def register(eureka_server: str, instance: Instance): ...
def cancel(eureka_server: str, app_name: str, instance_id: str): ...
def send_heart_beat(eureka_server: str, app_name: str, instance_id: str, last_dirty_timestamp: int, status: Union[INSTANCE_STATUS_UP, INSTANCE_STATUS_DOWN, INSTANCE_STATUS_STARTING, INSTANCE_STATUS_OUT_OF_SERVICE, INSTANCE_STATUS_UNKNOWN]=INSTANCE_STATUS_UP, overriddenstatus: Union[INSTANCE_STATUS_UP, INSTANCE_STATUS_DOWN, INSTANCE_STATUS_STARTING, INSTANCE_STATUS_OUT_OF_SERVICE, INSTANCE_STATUS_UNKNOWN, Literal[""]]="") -> None: ...
def status_update(eureka_server: str, app_name: str, instance_id: str, last_dirty_timestamp: int, status: Union[INSTANCE_STATUS_UP, INSTANCE_STATUS_DOWN, INSTANCE_STATUS_STARTING, INSTANCE_STATUS_OUT_OF_SERVICE, INSTANCE_STATUS_UNKNOWN]): ...
def delete_status_override(eureka_server: str, app_name: str, instance_id: str, last_dirty_timestamp: int): ...
def get_applications(eureka_server: str, regions: Sequence[str]=[]): ...
def get_delta(eureka_server: str, regions: Sequence[str]=[]): ...
def get_vip(eureka_server: str, vip: str, regions: Sequence[str]=[]): ...
def get_secure_vip(eureka_server: str, svip: str, regions: Sequence[str]=[]): ...
def get_application(eureka_server: str, app_name: str) -> Application: ...
def get_app_instance(eureka_server: str, app_name: str, instance_id: str): ...
def get_instance(eureka_server: str, instance_id: str): ...

class RegistryClient:
    """Eureka client for spring cloud"""
    def __init__(self, eureka_server: str=_DEFAULT_EUREKA_SERVER_URL, app_name: str="", instance_id: str="", instance_host: str="", instance_ip: str="", instance_port: int=_DEFAULT_INSTNACE_PORT, instance_unsecure_port_enabled: bool=True, instance_secure_port: int=_DEFAULT_INSTNACE_SECURE_PORT, instance_secure_port_enabled: bool=False, countryId: int=1, data_center_name: str=_DEFAULT_DATA_CENTER_INFO, renewal_interval_in_secs: int=_RENEWAL_INTERVAL_IN_SECS, duration_in_secs: int=_DURATION_IN_SECS, home_page_url: str="", status_page_url: str="", health_check_url: str="", secure_health_check_url: str="", vip_adr: str="", secure_vip_addr: str="", is_coordinating_discovery_server: bool=False, metadata: Dict[str, Any]={}) -> None: ...
    def register(self, status: Union[INSTANCE_STATUS_UP, INSTANCE_STATUS_DOWN, INSTANCE_STATUS_STARTING, INSTANCE_STATUS_OUT_OF_SERVICE, INSTANCE_STATUS_UNKNOWN]=INSTANCE_STATUS_UP, overriddenstatus: Union[INSTANCE_STATUS_UP, INSTANCE_STATUS_DOWN, INSTANCE_STATUS_STARTING, INSTANCE_STATUS_OUT_OF_SERVICE, INSTANCE_STATUS_UNKNOWN]=INSTANCE_STATUS_UNKNOWN) -> None: ...
    def cancel(self) -> None: ...
    def send_heart_beat(self, overridden_status: str=""): ...
    def status_update(self, new_status: Union[INSTANCE_STATUS_UP, INSTANCE_STATUS_DOWN, INSTANCE_STATUS_STARTING, INSTANCE_STATUS_OUT_OF_SERVICE, INSTANCE_STATUS_UNKNOWN]) -> None: ...
    def delete_status_override(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    
def init_registry_client(eureka_server: str=_DEFAULT_EUREKA_SERVER_URL, app_name: str="", instance_id: str="", instance_host: str="", instance_ip: str="", instance_port: int=_DEFAULT_INSTNACE_PORT, instance_unsecure_port_enabled: bool=True, instance_secure_port: int=_DEFAULT_INSTNACE_SECURE_PORT, instance_secure_port_enabled: bool=False, countryId: int=1, data_center_name: str=_DEFAULT_DATA_CENTER_INFO, renewal_interval_in_secs: int=_RENEWAL_INTERVAL_IN_SECS, duration_in_secs: int=_DURATION_IN_SECS, home_page_url: str="", status_page_url: str="", health_check_url: str="", secure_health_check_url: str="", vip_adr: str="", secure_vip_addr: str="", is_coordinating_discovery_server: bool=False, metadata: Dict[str, Any]={}) -> None: ...

def get_registry_client() -> Optional[RegistryClient]: ...

class DiscoveryClient:
    """Discover the apps registered in spring cloud server, this class will do some cached, if you want to get the apps immediatly, use the global functions"""
    def __init__(self, eureka_server: str, regions: Optional[Any]=None, renewal_interval_in_secs: int=_RENEWAL_INTERVAL_IN_SECS, ha_strategy: Union[HA_STRATEGY_RANDOM, HA_STRATEGY_STICK, HA_STRATEGY_OTHER]=HA_STRATEGY_RANDOM): ...
    @property
    def applications(self) -> Applications: ...    
    def walk_nodes_async(self, app_name: str="", service: str="", prefer_ip: bool=False, prefer_https: bool=False, walker: Optional[Callable[..., Any]]=None, on_success: Optional[Callable[[Union[str, Dict[Any, Any]]], object]]=None, on_error: Optional[Callable[[HTTPError], object]]=None) -> None: ...
    def walk_nodes(self, app_name: str="", service: str="", prefer_ip: bool=False, prefer_https: bool=False, walker: Optional[Callable[..., Any]]=None) -> None: ...
    def do_service_async(self, app_name: str="", service: str="", return_type: str="string", prefer_ip: bool=False, prefer_https: bool=False, on_success: Optional[Callable[[Union[str, Dict[Any, Any]]], object]]=None, on_error: Optional[Callable[[HTTPError], object]]=None, method: str="GET", headers: Optional[Dict[str, Any]]=None, data: Optional[Any]=None, timeout: int=_DEFAULT_TIME_OUT, cafile: Optional[Any] = ..., capath: Optional[Any] = ..., cadefault: bool = ..., context: Optional[Any] = ...): ...
    def do_service(self, app_name: str=..., service: str="", return_type: str="string", prefer_ip: bool=False, prefer_https: bool=False, method: str="GET", headers: Optional[Dict[str, Any]]=None, data: Optional[Any] = ..., timeout=..., cafile: Optional[Any] = ..., capath: Optional[Any] = ..., cadefault: bool = ..., context: Optional[Any] = ...): ...
    def start(self): ...
    def stop(self): ...
    
def init_discovery_client(eureka_server: str=..., regions=..., renewal_interval_in_secs=..., ha_strategy=...): ...
def get_discovery_client(): ...
def init(eureka_server: str=..., regions=..., app_name: str=..., instance_id: str=..., instance_host=..., instance_ip=..., instance_port=..., instance_unsecure_port_enabled: bool = ..., instance_secure_port=..., instance_secure_port_enabled: bool = ..., countryId: int=..., data_center_name=..., renewal_interval_in_secs=..., duration_in_secs=..., home_page_url=..., status_page_url=..., health_check_url=..., secure_health_check_url=..., vip_adr=..., secure_vip_addr=..., is_coordinating_discovery_server: bool = ..., metadata=..., ha_strategy=...): ...
def walk_nodes_async(app_name: str=..., service=..., prefer_ip: bool = ..., prefer_https: bool = ..., walker: Optional[Any] = ..., on_success: Optional[Any] = ..., on_error: Optional[Any] = ...): ...
def walk_nodes(app_name: str=..., service=..., prefer_ip: bool = ..., prefer_https: bool = ..., walker: Optional[Any] = ...): ...
def do_service_async(app_name: str=..., service=..., return_type=..., prefer_ip: bool = ..., prefer_https: bool = ..., on_success: Optional[Any] = ..., on_error: Optional[Any] = ..., method=..., headers: Optional[Any] = ..., data: Optional[Any] = ..., timeout=..., cafile: Optional[Any] = ..., capath: Optional[Any] = ..., cadefault: bool = ..., context: Optional[Any] = ...): ...
def do_service(app_name: str=..., service=..., return_type=..., prefer_ip: bool = ..., prefer_https: bool = ..., method=..., headers: Optional[Any] = ..., data: Optional[Any] = ..., timeout=..., cafile: Optional[Any] = ..., capath: Optional[Any] = ..., cadefault: bool = ..., context: Optional[Any] = ...): ...
def stop(): ...

@atexit.register
def _cleanup_before_exist(): ...

