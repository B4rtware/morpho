"""
This type stub file was generated by pyright.
"""

import socket
from waitress import trigger
from . import wasyncore
from typing import Any, Optional

def create_server(application, map: Optional[Any] = ..., _start: bool = ..., _sock: Optional[Any] = ..., _dispatcher: Optional[Any] = ..., **kw):
    """
    if __name__ == '__main__':
        server = create_server(app)
        server.run()
    """
    ...

class MultiSocketServer(object):
    asyncore = ...
    def __init__(self, map: Optional[Any] = ..., adj: Optional[Any] = ..., effective_listen: Optional[Any] = ..., dispatcher: Optional[Any] = ...):
        self.adj = ...
        self.map = ...
        self.effective_listen = ...
        self.task_dispatcher = ...
    
    def print_listen(self, format_str):
        ...
    
    def run(self):
        ...
    
    def close(self):
        ...
    


class BaseWSGIServer(wasyncore.dispatcher, object):
    channel_class = ...
    next_channel_cleanup = ...
    socketmod = ...
    asyncore = ...
    def __init__(self, application, map: Optional[Any] = ..., _start: bool = ..., _sock: Optional[Any] = ..., dispatcher: Optional[Any] = ..., adj: Optional[Any] = ..., sockinfo: Optional[Any] = ..., bind_socket: bool = ..., **kw):
        self.sockinfo = ...
        self.family = ...
        self.socktype = ...
        self.application = ...
        self.adj = ...
        self.trigger = ...
        self.task_dispatcher = ...
        self.server_name = ...
        self.active_channels = ...
    
    def bind_server_socket(self):
        ...
    
    def get_server_name(self, ip):
        """Given an IP or hostname, try to determine the server name."""
        ...
    
    def getsockname(self):
        ...
    
    def accept_connections(self):
        self.accepting = ...
    
    def add_task(self, task):
        ...
    
    def readable(self):
        ...
    
    def writable(self):
        ...
    
    def handle_read(self):
        ...
    
    def handle_connect(self):
        ...
    
    def handle_accept(self):
        ...
    
    def run(self):
        ...
    
    def pull_trigger(self):
        ...
    
    def set_socket_options(self, conn):
        ...
    
    def fix_addr(self, addr):
        ...
    
    def maintenance(self, now):
        """
        Closes channels that have not had any activity in a while.

        The timeout is configured through adj.channel_timeout (seconds).
        """
        ...
    
    def print_listen(self, format_str):
        ...
    
    def close(self):
        ...
    


class TcpWSGIServer(BaseWSGIServer):
    def bind_server_socket(self):
        ...
    
    def getsockname(self):
        ...
    
    def set_socket_options(self, conn):
        ...
    


if hasattr(socket, "AF_UNIX"):
    class UnixWSGIServer(BaseWSGIServer):
        def __init__(self, application, map: Optional[Any] = ..., _start: bool = ..., _sock: Optional[Any] = ..., dispatcher: Optional[Any] = ..., adj: Optional[Any] = ..., sockinfo: Optional[Any] = ..., **kw):
            ...
        
        def bind_server_socket(self):
            ...
        
        def getsockname(self):
            ...
        
        def fix_addr(self, addr):
            ...
        
        def get_server_name(self, ip):
            ...
        
    
    
WSGIServer = TcpWSGIServer
