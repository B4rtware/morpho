"""
This type stub file was generated by pyright.
"""
from __future__ import annotations

import contextlib
import logging
import re
import socket
from typing import (
    Any,
    Callable,
    Dict,
    List,
    Optional,
    Pattern,
    TYPE_CHECKING,
    TypeVar,
    Union,
)

from httpretty import Response

# from httpretty import CONNECT, DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT

from .compat import BaseClass, BaseHTTPRequestHandler
from .http import HttpBaseClass

Method = Union[
    HttpBaseClass.GET,
    HttpBaseClass.PUT,
    HttpBaseClass.POST,
    HttpBaseClass.DELETE,
    HttpBaseClass.HEAD,
    HttpBaseClass.PATCH,
    HttpBaseClass.OPTIONS,
    HttpBaseClass.CONNECT,
]

Uri = Union[Pattern[str], str]

_T = TypeVar("_T")

Headers = Dict[str, str]

old_socket = socket.socket
old_SocketType = socket.SocketType
old_create_connection = socket.create_connection
old_gethostbyname = socket.gethostbyname
old_gethostname = socket.gethostname
old_getaddrinfo = socket.getaddrinfo
old_socksocket = None
old_ssl_wrap_socket = None
old_sslwrap_simple = None
old_sslsocket = None
old_sslcontext_wrap_socket = None
old_sslcontext = None
MULTILINE_ANY_REGEX: Pattern[str] = re.compile(r".*", re.M)
hostname_re: Pattern[str] = re.compile(r"\^?(?:https?://)?[^:/]*[:/]?")
logger = logging.getLogger(__name__)
DEFAULT_HTTP_PORTS = frozenset([80])
POTENTIAL_HTTP_PORTS = set(DEFAULT_HTTP_PORTS)
DEFAULT_HTTPS_PORTS = frozenset([443])
POTENTIAL_HTTPS_PORTS = set(DEFAULT_HTTPS_PORTS)

def FALLBACK_FUNCTION(x): ...

class HTTPrettyRequest(BaseHTTPRequestHandler, BaseClass):
    r"""
    Represents a HTTP request. It takes a valid multi-line,
    ``\r\n`` separated string with HTTP headers and parse them out using
    the internal `parse_request` method.

    It also replaces the `rfile` and `wfile` attributes with :py:class:`io.BytesIO`
    instances so that we guarantee that it won't make any I/O, neither
    for writing nor reading.

    It has some convenience attributes:

    ``headers`` -> a mimetype object that can be cast into a dictionary,
    contains all the request headers

    ``method`` -> the HTTP method used in this request

    ``querystring`` -> a dictionary containing lists with the
    attributes. Please notice that if you need a single value from a
    query string you will need to get it manually like:

    ``body`` -> the request body as a string

    ``parsed_body`` -> the request body parsed by ``parse_request_body``

    .. testcode::

      >>> request.querystring
      {'name': ['Gabriel Falcao']}
      >>> print request.querystring['name'][0]



    """
    def __init__(self, headers, body=...):
        self.raw_headers = ...
        self.rfile = ...
        self.wfile = ...
        self.raw_requestline = ...
        self.error_code = ...
        self.error_message = ...
        self.method = ...
        self.path = ...
        self.querystring = ...
        self.parsed_body = ...
    @property
    def body(self): ...
    @body.setter
    def body(self, value):
        self.parsed_body = ...
    def __nonzero__(self): ...
    def __str__(self): ...
    def parse_querystring(self, qs):
        """parses an UTF-8 encoded query string into a dict of string lists

        :param qs: a querystring
        :returns: a dict of lists

        """
        ...
    def parse_request_body(self, body):
        """Attempt to parse the post based on the content-type passed.
        Return the regular body if not

        :param body: string
        :returns: a python object such as dict or list in case the deserialization suceeded. Else returns the given param ``body``
        """
        ...

class EmptyRequestHeaders(dict):
    """A dict subclass used as internal representation of empty request
    headers
    """

    ...

class HTTPrettyRequestEmpty(object):
    """Represents an empty :py:class:`~httpretty.core.HTTPrettyRequest`
    where all its properties are somehow empty or ``None``
    """

    method = ...
    url = ...
    body = ...
    headers = ...

class FakeSockFile(object):
    """Fake socket file descriptor. Under the hood all data is written in
    a temporary file, giving it a real file descriptor number.

    """

    def __init__(self):
        self.file = ...
    def getvalue(self): ...
    def close(self): ...
    def fileno(self): ...
    def __getattr__(self, name): ...
    def __del__(self): ...

class FakeSSLSocket(object):
    """Shorthand for :py:class:`~httpretty.core.fakesock`
    """

    def __init__(self, sock, *args, **kw): ...
    def __getattr__(self, attr): ...

class FakeAddressTuple(object):
    def __init__(self, fakesocket):
        self.fakesocket = ...
    def __getitem__(self, *args, **kw): ...

class fakesock(object):
    """
    fake :py:mod:`socket`
    """

    class socket(object):
        """drop-in replacement for :py:class:`socket.socket`
        """

        _entry = ...
        debuglevel = ...
        _sent_data = ...
        def __init__(
            self, family=..., type=..., proto=..., fileno: Optional[Any] = ...
        ):
            self.socket_family = ...
            self.socket_type = ...
            self.socket_proto = ...
            self.__truesock_is_connected__ = ...
            self.fd = ...
            self.timeout = ...
            self.is_http = ...
        def create_socket(self): ...
        def getpeercert(self, *a, **kw): ...
        def ssl(self, sock, *args, **kw): ...
        def setsockopt(self, level, optname, value): ...
        def connect(self, address): ...
        def bind(self, address): ...
        def bind_truesock(self, address): ...
        def connect_truesock(self): ...
        def real_socket_is_connected(self): ...
        def fileno(self): ...
        def close(self): ...
        def makefile(self, mode=..., bufsize=...):
            """Returns this fake socket's own tempfile buffer.

            If there is an entry associated with the socket, the file
            descriptor gets filled in with the entry data before being
            returned.
            """
            ...
        def real_sendall(self, data, *args, **kw):
            """Sends data to the remote server. This method is called
            when HTTPretty identifies that someone is trying to send
            non-http data.

            The received bytes are written in this socket's tempfile
            buffer so that HTTPretty can return it accordingly when
            necessary.
            """
            ...
        def sendall(self, data, *args, **kw):
            self.fd = ...
        def forward_and_trace(self, function_name, *a, **kw): ...
        def settimeout(self, new_timeout):
            self.timeout = ...
        def send(self, *args, **kwargs): ...
        def sendto(self, *args, **kwargs): ...
        def recvfrom_into(self, *args, **kwargs): ...
        def recv_into(self, *args, **kwargs): ...
        def recvfrom(self, *args, **kwargs): ...
        def recv(self, buffersize: Optional[Any] = ..., *args, **kwargs): ...
        def __getattr__(self, name): ...

def fake_wrap_socket(orig_wrap_socket_fn, *args, **kw):
    """drop-in replacement for py:func:`ssl.wrap_socket`
    """
    ...

def create_fake_connection(address, timeout=..., source_address: Optional[Any] = ...):
    """drop-in replacement for :py:func:`socket.create_connection`"""
    ...

def fake_gethostbyname(host):
    """drop-in replacement for :py:func:`socket.gethostbyname`"""
    ...

def fake_gethostname():
    """drop-in replacement for :py:func:`socket.gethostname`"""
    ...

def fake_getaddrinfo(
    host,
    port,
    family: Optional[Any] = ...,
    socktype: Optional[Any] = ...,
    proto: Optional[Any] = ...,
    flags: Optional[Any] = ...,
):
    """drop-in replacement for :py:func:`socket.getaddrinfo`"""
    ...

class Entry(BaseClass):
    """Created by :py:meth:`~httpretty.core.httpretty.register_uri` and
    stored in memory as internal representation of a HTTP
    request/response definition.

    Args:
        method (str): One of ``httpretty.GET``, ``httpretty.PUT``, ``httpretty.POST``, ``httpretty.DELETE``, ``httpretty.HEAD``, ``httpretty.PATCH``, ``httpretty.OPTIONS``, ``httpretty.CONNECT``.
        uri (str|re.Pattern): The URL to match
        adding_headers (dict): Extra headers to be added to the response
        forcing_headers (dict): Overwrite response headers.
        status (int): The status code for the response, defaults to ``200``.
        streaming (bool): Whether should stream the response into chunks via generator.
        headers: Headers to inject in the faked response.

    Returns:
        httpretty.Entry: containing the request-matching metadata.


    .. warning:: When using the ``forcing_headers`` option make sure to add the header ``Content-Length`` to match at most the total body length, otherwise some HTTP clients can hang indefinitely.
    """

    def __init__(
        self,
        method: Method,
        uri: Uri,
        body: str,
        adding_headers: Optional[Headers] = None,
        forcing_headers: Optional[Headers] = None,
        status: int = 200,
        streaming: bool = False,
        **headers: Headers,
    ):
        self.method = ...
        self.uri = ...
        self.info = ...
        self.request = ...
        self.body_is_callable = ...
        self.streaming = ...
        self.adding_headers = ...
        self.forcing_headers = ...
        self.status = ...
    def validate(self):
        """validates the body size with the value of the ``Content-Length``
        header
        """
        ...
    def __str__(self): ...
    def normalize_headers(self, headers):
        """Normalize keys in header names so that ``COntent-tyPe`` becomes ``content-type``

        :param headers: dict

        :returns: dict
        """
        ...
    def fill_filekind(self, fk):
        """writes HTTP Response data to a file descriptor

        :parm fk: a file-like object

        .. warning:: **side-effect:** this method moves the cursor of the given file object to zero
        """
        ...

def url_fix(s, charset: Optional[Any] = ...):
    """escapes special characters
    """
    ...

class URIInfo(BaseClass):
    """Internal representation of `URIs <https://en.wikipedia.org/wiki/Uniform_Resource_Identifier>`_

    .. tip:: all arguments are optional

    :param username:
    :param password:
    :param hostname:
    :param port:
    :param path:
    :param query:
    :param fragment:
    :param scheme:
    :param last_request:
    """

    default_str_attrs = ...
    def __init__(
        self,
        username=...,
        password=...,
        hostname=...,
        port=...,
        path=...,
        query=...,
        fragment=...,
        scheme=...,
        last_request: Optional[Any] = ...,
    ):
        self.username = ...
        self.password = ...
        self.hostname = ...
        self.port = ...
        self.path = ...
        self.fragment = ...
        self.last_request = ...
    def to_str(self, attrs): ...
    def __str__(self): ...
    def str_with_query(self): ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def full_url(self, use_querystring: bool = ...):
        """
        :param use_querystring: bool
        :returns: a string with the full url with the format ``{scheme}://{credentials}{domain}{path}{query}``
        """
        ...
    def get_full_domain(self):
        """
        :returns: a string in the form ``{domain}:{port}`` or just the domain if the port is 80 or 443
        """
        ...
    @classmethod
    def from_uri(cls, uri, entry):
        """
        :param uri: string
        :param entry: an instance of :py:class:`~httpretty.core.Entry`
        """
        ...

class URIMatcher(object):
    regex = ...
    info = ...
    def __init__(self, uri, entries, match_querystring: bool = ..., priority=...):
        self.entries = ...
        self.priority = ...
        self.uri = ...
        self.current_entries = ...
    def matches(self, info): ...
    def __str__(self): ...
    def get_next_entry(self, method, info, request):
        """Cycle through available responses, but only once.
        Any subsequent requests will receive the last response"""
        ...
    def __hash__(self): ...
    def __eq__(self, other): ...

class httpretty(HttpBaseClass):
    """manages HTTPretty's internal request/response registry and request matching.
    """

    _entries = ...
    latest_requests = ...
    last_request = ...
    _is_enabled = ...
    allow_net_connect = ...
    @classmethod
    def match_uriinfo(cls, info):
        """
        :param info: an :py:class:`~httpretty.core.URIInfo`
        :returns: a 2-item tuple: (:py:class:`~httpretty.core.URLMatcher`, :py:class:`~httpretty.core.URIInfo`) or ``(None, [])``
        """
        ...
    @classmethod
    def match_https_hostname(cls, hostname):
        """
        :param hostname: a string
        :returns: an :py:class:`~httpretty.core.URLMatcher` or ``None``
        """
        ...
    @classmethod
    def match_http_address(cls, hostname, port):
        """
        :param hostname: a string
        :param port: an integer
        :returns: an :py:class:`~httpretty.core.URLMatcher` or ``None``
        """
        ...
    @classmethod
    @contextlib.contextmanager
    def record(cls, filename, indentation=..., encoding=...):
        """
        .. testcode::

           import io
           import json
           import requests
           import httpretty

           with httpretty.record('/tmp/ip.json'):
               data = requests.get('https://httpbin.org/ip').json()

           with io.open('/tmp/ip.json') as fd:
               assert data == json.load(fd)

        :param filename: a string
        :param indentation: an integer, defaults to **4**
        :param encoding: a string, defaults to **"utf-8"**

        :returns: a `context-manager <https://docs.python.org/3/reference/datamodel.html#context-managers>`_
        """
        ...
    @classmethod
    @contextlib.contextmanager
    def playback(cls, filename):
        """
        .. testcode::

           import io
           import json
           import requests
           import httpretty

           with httpretty.record('/tmp/ip.json'):
               data = requests.get('https://httpbin.org/ip').json()

           with io.open('/tmp/ip.json') as fd:
               assert data == json.load(fd)

        :param filename: a string
        :returns: a `context-manager <https://docs.python.org/3/reference/datamodel.html#context-managers>`_
        """
        ...
    @classmethod
    def reset(cls):
        """resets the internal state of HTTPretty, unregistering all URLs
        """
        ...
    @classmethod
    def historify_request(cls, headers, body=..., append: bool = ...):
        """appends request to a list for later retrieval

        .. testcode::

           import httpretty

           httpretty.register_uri(httpretty.GET, 'https://httpbin.org/ip', body='')
           with httpretty.enabled():
               requests.get('https://httpbin.org/ip')

           assert httpretty.latest_requests[-1].url == 'https://httpbin.org/ip'
        """
        ...
    @classmethod
    def register_uri(
        cls: Type[_T],
        method: Method,
        uri: Uri,
        body: str = "",
        adding_headers: Optional[Headers] = None,
        forcing_headers: Optional[Headers] = None,
        status: int = 200,
        responses: Optional[List[int]] = None,
        match_querystring: bool = False,
        priority: int = 0,
        **headers: Headers,
    ) -> _T:
        """
        .. testcode::

           import httpretty


           def request_callback(request, uri, response_headers):
               content_type = request.headers.get('Content-Type')
               assert request.body == '{"nothing": "here"}', 'unexpected body: {}'.format(request.body)
               assert content_type == 'application/json', 'expected application/json but received Content-Type: {}'.format(content_type)
               return [200, response_headers, json.dumps({"hello": "world"})]

           httpretty.register_uri(
               HTTPretty.POST, "https://httpretty.example.com/api",
               body=request_callback)


           with httpretty.enabled():
               requests.post('https://httpretty.example.com/api', data='{"nothing": "here"}', headers={'Content-Type': 'application/json'})

           assert httpretty.latest_requests[-1].url == 'https://httpbin.org/ip'

        :param method: one of ``httpretty.GET``, ``httpretty.PUT``, ``httpretty.POST``, ``httpretty.DELETE``, ``httpretty.HEAD``, ``httpretty.PATCH``, ``httpretty.OPTIONS``, ``httpretty.CONNECT``
        :param uri: a string or regex pattern (e.g.: **"https://httpbin.org/ip"**)
        :param body: a string, defaults to ``{"message": "HTTPretty :)"}``
        :param adding_headers: dict - headers to be added to the response
        :param forcing_headers: dict - headers to be forcefully set in the response
        :param status: an integer, defaults to **200**
        :param responses: a list of entries, ideally each created with :py:meth:`~httpretty.core.httpretty.Response`
        :param priority: an integer, useful for setting higher priority over previously registered urls. defaults to zero
        :param match_querystring: bool - whether to take the querystring into account when matching an URL
        :param headers: headers to be added to the response

        .. warning:: When using a port in the request, add a trailing slash if no path is provided otherwise Httpretty will not catch the request.  Ex: ``httpretty.register_uri(httpretty.GET, 'http://fakeuri.com:8080/', body='{"hello":"world"}')``
        """
        ...
    def __str__(self): ...
    @classmethod
    def Response(
        cls,
        body,
        method: Optional[Method] = None,
        uri: Union[Pattern[str], str] = None,
        adding_headers: Optional[Headers] = None,
        forcing_headers: Optional[Headers] = None,
        status: int = 200,
        streaming: bool = False,
        **kw: Headers,
    ) -> Entry:
        """Shortcut to create an :py:class:`~httpretty.core.Entry` that takes
        the body as first positional argument.

        .. seealso:: the parameters of this function match those of
                     the :py:class:`~httpretty.core.Entry` constructor.

        Args:
            body (str): The body to return as response..
            method (str): One of ``httpretty.GET``, ``httpretty.PUT``, ``httpretty.POST``, ``httpretty.DELETE``, ``httpretty.HEAD``, ``httpretty.PATCH``, ``httpretty.OPTIONS``, ``httpretty.CONNECT``.
            uri (str|re.Pattern): The URL to match
            adding_headers (dict): Extra headers to be added to the response
            forcing_headers (dict): Overwrite **any** response headers, even "Content-Length".
            status (int): The status code for the response, defaults to ``200``.
            streaming (bool): Whether should stream the response into chunks via generator.
            kwargs: Keyword-arguments are forwarded to :py:class:`~httpretty.core.Entry`

        Returns:
            httpretty.Entry: containing the request-matching metadata.
        """
        ...
    @classmethod
    def disable(cls):
        """Disables HTTPretty entirely, putting the original :py:mod:`socket`
        module back in its place.


        .. code::

           import re, json
           import httpretty

           httpretty.enable()
           # request passes through fake socket
           response = requests.get('https://httpbin.org')

           httpretty.disable()
           # request uses real python socket module
           response = requests.get('https://httpbin.org')

        .. note:: This method does not call :py:meth:`httpretty.core.reset` automatically.
        """
        ...
    @classmethod
    def is_enabled(cls):
        """Check if HTTPretty is enabled

        :returns: bool

        .. testcode::

           import httpretty

           httpretty.enable()
           assert httpretty.is_enabled() == True

           httpretty.disable()
           assert httpretty.is_enabled() == False
        """
        ...
    @classmethod
    def enable(cls, allow_net_connect: bool = ...):
        """Enables HTTPretty.
        When ``allow_net_connect`` is ``False`` any connection to an unregistered uri will throw :py:class:`httpretty.errors.UnmockedError`.

        .. testcode::

           import re, json
           import httpretty

           httpretty.enable()

           httpretty.register_uri(
               httpretty.GET,
               re.compile(r'http://.*'),
               body=json.dumps({'man': 'in', 'the': 'middle'})
           )

           response = requests.get('https://foo.bar/foo/bar')

           response.json().should.equal({
               "man": "in",
               "the": "middle",
           })

        .. warning:: after calling this method the original :py:mod:`socket` is replaced with :py:class:`httpretty.core.fakesock`. Make sure to call :py:meth:`~httpretty.disable` after done with your tests or use the :py:class:`httpretty.enabled` as decorator or `context-manager <https://docs.python.org/3/reference/datamodel.html#context-managers>`_
        """
        ...

def apply_patch_socket(): ...
def undo_patch_socket(): ...
@contextlib.contextmanager
def restored_libs(): ...

class httprettized(object):
    """`context-manager <https://docs.python.org/3/reference/datamodel.html#context-managers>`_ for enabling HTTPretty.

    .. tip:: Also available under the alias :py:func:`httpretty.enabled`

    .. testcode::

       import json
       import httpretty

       httpretty.register_uri(httpretty.GET, 'https://httpbin.org/ip', body=json.dumps({'origin': '42.42.42.42'}))
       with httpretty.enabled():
           response = requests.get('https://httpbin.org/ip')

       assert httpretty.latest_requests[-1].url == 'https://httpbin.org/ip'
       assert response.json() == {'origin': '42.42.42.42'}
    """

    def __init__(self, allow_net_connect: bool = ...):
        self.allow_net_connect = ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_value, db): ...

def httprettified(test: Optional[_T] = None, allow_net_connect: bool = True) -> _T:
    """decorator for test functions

    .. tip:: Also available under the alias :py:func:`httpretty.activate`

    :param test: a callable


    example usage with `nosetests <https://nose.readthedocs.io/en/latest/>`_

    .. testcode::

       import sure
       from httpretty import httprettified

       @httprettified
       def test_using_nosetests():
           httpretty.register_uri(
               httpretty.GET,
               'https://httpbin.org/ip'
           )

           response = requests.get('https://httpbin.org/ip')

           response.json().should.equal({
               "message": "HTTPretty :)"
           })

    example usage with `unittest module <https://docs.python.org/3/library/unittest.html>`_

    .. testcode::

       import unittest
       from sure import expect
       from httpretty import httprettified

       @httprettified
       class TestWithPyUnit(unittest.TestCase):
           def test_httpbin(self):
               httpretty.register_uri(httpretty.GET, 'https://httpbin.org/ip')
               response = requests.get('https://httpbin.org/ip')
               expect(response.json()).to.equal({
                   "message": "HTTPretty :)"
               })

    """
    ...

