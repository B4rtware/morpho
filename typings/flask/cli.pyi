"""
This type stub file was generated by pyright.
"""

import os
import click
from typing import Any, Optional

"""
    flask.cli
    ~~~~~~~~~

    A simple command line application to run flask apps.

    :copyright: 2010 Pallets
    :license: BSD-3-Clause
"""
class NoAppException(click.UsageError):
    """Raised if an application cannot be found or loaded."""
    ...


def find_best_app(script_info, module):
    """Given a module instance this tries to find the best possible
    application in the module or raises an exception.
    """
    ...

def call_factory(script_info, app_factory, arguments=...):
    """Takes an app factory, a ``script_info` object and  optionally a tuple
    of arguments. Checks for the existence of a script_info argument and calls
    the app_factory depending on that and the arguments provided.
    """
    ...

def _called_with_wrong_args(factory):
    """Check whether calling a function raised a ``TypeError`` because
    the call failed or because something in the factory raised the
    error.

    :param factory: the factory function that was called
    :return: true if the call failed
    """
    ...

def find_app_by_string(script_info, module, app_name):
    """Checks if the given string is a variable name or a function. If it is a
    function, it checks for specified arguments and whether it takes a
    ``script_info`` argument and calls the function with the appropriate
    arguments.
    """
    ...

def prepare_import(path):
    """Given a filename this will try to calculate the python path, add it
    to the search path and return the actual module name that is expected.
    """
    ...

def locate_app(script_info, module_name, app_name, raise_if_not_found: bool = ...):
    ...

def get_version(ctx, param, value):
    ...

version_option = click.Option(["--version"], help="Show the flask version", expose_value=False, callback=get_version, is_flag=True, is_eager=True)
class DispatchingApp(object):
    """Special application that dispatches to a Flask application which
    is imported by name in a background thread.  If an error happens
    it is recorded and shown as part of the WSGI handling which in case
    of the Werkzeug debugger means that it shows up in the browser.
    """
    def __init__(self, loader, use_eager_loading: bool = ...):
        self.loader = ...
    
    def _load_in_background(self):
        ...
    
    def _flush_bg_loading_exception(self):
        ...
    
    def _load_unlocked(self):
        ...
    
    def __call__(self, environ, start_response):
        ...
    


class ScriptInfo(object):
    """Helper object to deal with Flask applications.  This is usually not
    necessary to interface with as it's used internally in the dispatching
    to click.  In future versions of Flask this object will most likely play
    a bigger role.  Typically it's created automatically by the
    :class:`FlaskGroup` but you can also manually create it and pass it
    onwards as click object.
    """
    def __init__(self, app_import_path: Optional[Any] = ..., create_app: Optional[Any] = ..., set_debug_flag: bool = ...):
        self.app_import_path = ...
        self.create_app = ...
        self.data = ...
        self.set_debug_flag = ...
    
    def load_app(self):
        """Loads the Flask app (if not yet loaded) and returns it.  Calling
        this multiple times will just result in the already loaded app to
        be returned.
        """
        ...
    


pass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)
def with_appcontext(f):
    """Wraps a callback so that it's guaranteed to be executed with the
    script's application context.  If callbacks are registered directly
    to the ``app.cli`` object then they are wrapped with this function
    by default unless it's disabled.
    """
    ...

class AppGroup(click.Group):
    """This works similar to a regular click :class:`~click.Group` but it
    changes the behavior of the :meth:`command` decorator so that it
    automatically wraps the functions in :func:`with_appcontext`.

    Not to be confused with :class:`FlaskGroup`.
    """
    def command(self, *args, **kwargs):
        """This works exactly like the method of the same name on a regular
        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`
        unless it's disabled by passing ``with_appcontext=False``.
        """
        ...
    
    def group(self, *args, **kwargs):
        """This works exactly like the method of the same name on a regular
        :class:`click.Group` but it defaults the group class to
        :class:`AppGroup`.
        """
        ...
    


class FlaskGroup(AppGroup):
    """Special subclass of the :class:`AppGroup` group that supports
    loading more commands from the configured Flask app.  Normally a
    developer does not have to interface with this class but there are
    some very advanced use cases for which it makes sense to create an
    instance of this.

    For information as of why this is useful see :ref:`custom-scripts`.

    :param add_default_commands: if this is True then the default run and
        shell commands will be added.
    :param add_version_option: adds the ``--version`` option.
    :param create_app: an optional callback that is passed the script info and
        returns the loaded app.
    :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
        files to set environment variables. Will also change the working
        directory to the directory containing the first file found.
    :param set_debug_flag: Set the app's debug flag based on the active
        environment

    .. versionchanged:: 1.0
        If installed, python-dotenv will be used to load environment variables
        from :file:`.env` and :file:`.flaskenv` files.
    """
    def __init__(self, add_default_commands: bool = ..., create_app: Optional[Any] = ..., add_version_option: bool = ..., load_dotenv: bool = ..., set_debug_flag: bool = ..., **extra):
        self.create_app = ...
        self.load_dotenv = ...
        self.set_debug_flag = ...
    
    def _load_plugin_commands(self):
        ...
    
    def get_command(self, ctx, name):
        ...
    
    def list_commands(self, ctx):
        ...
    
    def main(self, *args, **kwargs):
        ...
    


def _path_is_ancestor(path, other):
    """Take ``other`` and remove the length of ``path`` from it. Then join it
    to ``path``. If it is the original value, ``path`` is an ancestor of
    ``other``."""
    ...

def load_dotenv(path: Optional[Any] = ...):
    """Load "dotenv" files in order of precedence to set environment variables.

    If an env var is already set it is not overwritten, so earlier files in the
    list are preferred over later files.

    Changes the current working directory to the location of the first file
    found, with the assumption that it is in the top level project directory
    and will be where the Python path should import local packages from.

    This is a no-op if `python-dotenv`_ is not installed.

    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme

    :param path: Load the file at this location instead of searching.
    :return: ``True`` if a file was loaded.

    .. versionchanged:: 1.1.0
        Returns ``False`` when python-dotenv is not installed, or when
        the given path isn't a file.

    .. versionadded:: 1.0
    """
    ...

def show_server_banner(env, debug, app_import_path, eager_loading):
    """Show extra startup messages the first time the server is run,
    ignoring the reloader.
    """
    ...

class CertParamType(click.ParamType):
    """Click option type for the ``--cert`` option. Allows either an
    existing file, the string ``'adhoc'``, or an import for a
    :class:`~ssl.SSLContext` object.
    """
    name = ...
    def __init__(self):
        self.path_type = ...
    
    def convert(self, value, param, ctx):
        ...
    


def _validate_key(ctx, param, value):
    """The ``--key`` option must be specified when ``--cert`` is a file.
    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.
    """
    ...

class SeparatedPathType(click.Path):
    """Click option type that accepts a list of values separated by the
    OS's path separator (``:``, ``;`` on Windows). Each value is
    validated as a :class:`click.Path` type.
    """
    def convert(self, value, param, ctx):
        ...
    


@click.command("run", short_help="Run a development server.")
@click.option("--host", "-h", default="127.0.0.1", help="The interface to bind to.")
@click.option("--port", "-p", default=5000, help="The port to bind to.")
@click.option("--cert", type=CertParamType(), help="Specify a certificate file to use HTTPS.")
@click.option("--key", type=click.Path(exists=True, dir_okay=False, resolve_path=True), callback=_validate_key, expose_value=False, help="The key file to use when specifying a certificate.")
@click.option("--reload/--no-reload", default=None, help="Enable or disable the reloader. By default the reloader " "is active if debug is enabled.")
@click.option("--debugger/--no-debugger", default=None, help="Enable or disable the debugger. By default the debugger " "is active if debug is enabled.")
@click.option("--eager-loading/--lazy-loader", default=None, help="Enable or disable eager loading. By default eager " "loading is enabled if the reloader is disabled.")
@click.option("--with-threads/--without-threads", default=True, help="Enable or disable multithreading.")
@click.option("--extra-files", default=None, type=SeparatedPathType(), help="Extra files that trigger a reload on change. Multiple paths" " are separated by '{}'.".format(os.path.pathsep))
@pass_script_info
def run_command(info, host, port, reload, debugger, eager_loading, with_threads, cert, extra_files):
    """Run a local development server.

    This server is for development purposes only. It does not provide
    the stability, security, or performance of production WSGI servers.

    The reloader and debugger are enabled by default if
    FLASK_ENV=development or FLASK_DEBUG=1.
    """
    ...

@click.command("shell", short_help="Run a shell in the app context.")
@with_appcontext
def shell_command():
    """Run an interactive Python shell in the context of a given
    Flask application.  The application will populate the default
    namespace of this shell according to it's configuration.

    This is useful for executing small snippets of management code
    without having to manually configure the application.
    """
    ...

@click.command("routes", short_help="Show the routes for the app.")
@click.option("--sort", "-s", type=click.Choice(("endpoint", "methods", "rule", "match")), default="endpoint", help='Method to sort routes by. "match" is the order that Flask will match ' "routes when dispatching a request.")
@click.option("--all-methods", is_flag=True, help="Show HEAD and OPTIONS methods.")
@with_appcontext
def routes_command(sort, all_methods):
    """Show all registered routes with endpoints and methods."""
    ...

cli = FlaskGroup(help="""\
A general utility script for Flask applications.

Provides commands from Flask, extensions, and the application. Loads the
application defined in the FLASK_APP environment variable, or from a wsgi.py
file. Setting the FLASK_ENV environment variable to 'development' will enable
debug mode.

\b
  {prefix}{cmd} FLASK_APP=hello.py
  {prefix}{cmd} FLASK_ENV=development
  {prefix}flask run
""".format(cmd="export" if os.name == "posix" else "set", prefix="$ " if os.name == "posix" else "> "))
def main(as_module: bool = ...):
    ...

if __name__ == "__main__":
    ...
