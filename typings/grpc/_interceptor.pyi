"""
This type stub file was generated by pyright.
"""

import collections
import grpc
from typing import Any, Optional

"""Implementation of gRPC Python interceptors."""
class _ServicePipeline(object):
    def __init__(self, interceptors):
        self.interceptors = ...
    
    def _continuation(self, thunk, index):
        ...
    
    def _intercept_at(self, thunk, index, context):
        ...
    
    def execute(self, thunk, context):
        ...
    


def service_pipeline(interceptors):
    ...

class _ClientCallDetails(collections.namedtuple('_ClientCallDetails', ('method', 'timeout', 'metadata', 'credentials', 'wait_for_ready', 'compression')), grpc.ClientCallDetails):
    ...


def _unwrap_client_call_details(call_details, default_details):
    ...

class _FailureOutcome(grpc.RpcError, grpc.Future, grpc.Call):
    def __init__(self, exception, traceback):
        ...
    
    def initial_metadata(self):
        ...
    
    def trailing_metadata(self):
        ...
    
    def code(self):
        ...
    
    def details(self):
        ...
    
    def cancel(self):
        ...
    
    def cancelled(self):
        ...
    
    def is_active(self):
        ...
    
    def time_remaining(self):
        ...
    
    def running(self):
        ...
    
    def done(self):
        ...
    
    def result(self, ignored_timeout: Optional[Any] = ...):
        ...
    
    def exception(self, ignored_timeout: Optional[Any] = ...):
        ...
    
    def traceback(self, ignored_timeout: Optional[Any] = ...):
        ...
    
    def add_callback(self, unused_callback):
        ...
    
    def add_done_callback(self, fn):
        ...
    
    def __iter__(self):
        ...
    
    def __next__(self):
        ...
    
    def next(self):
        ...
    


class _UnaryOutcome(grpc.Call, grpc.Future):
    def __init__(self, response, call):
        ...
    
    def initial_metadata(self):
        ...
    
    def trailing_metadata(self):
        ...
    
    def code(self):
        ...
    
    def details(self):
        ...
    
    def is_active(self):
        ...
    
    def time_remaining(self):
        ...
    
    def cancel(self):
        ...
    
    def add_callback(self, callback):
        ...
    
    def cancelled(self):
        ...
    
    def running(self):
        ...
    
    def done(self):
        ...
    
    def result(self, ignored_timeout: Optional[Any] = ...):
        ...
    
    def exception(self, ignored_timeout: Optional[Any] = ...):
        ...
    
    def traceback(self, ignored_timeout: Optional[Any] = ...):
        ...
    
    def add_done_callback(self, fn):
        ...
    


class _UnaryUnaryMultiCallable(grpc.UnaryUnaryMultiCallable):
    def __init__(self, thunk, method, interceptor):
        ...
    
    def __call__(self, request, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    
    def _with_call(self, request, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    
    def with_call(self, request, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    
    def future(self, request, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    


class _UnaryStreamMultiCallable(grpc.UnaryStreamMultiCallable):
    def __init__(self, thunk, method, interceptor):
        ...
    
    def __call__(self, request, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    


class _StreamUnaryMultiCallable(grpc.StreamUnaryMultiCallable):
    def __init__(self, thunk, method, interceptor):
        ...
    
    def __call__(self, request_iterator, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    
    def _with_call(self, request_iterator, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    
    def with_call(self, request_iterator, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    
    def future(self, request_iterator, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    


class _StreamStreamMultiCallable(grpc.StreamStreamMultiCallable):
    def __init__(self, thunk, method, interceptor):
        ...
    
    def __call__(self, request_iterator, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    


class _Channel(grpc.Channel):
    def __init__(self, channel, interceptor):
        ...
    
    def subscribe(self, callback, try_to_connect: bool = ...):
        ...
    
    def unsubscribe(self, callback):
        ...
    
    def unary_unary(self, method, request_serializer: Optional[Any] = ..., response_deserializer: Optional[Any] = ...):
        ...
    
    def unary_stream(self, method, request_serializer: Optional[Any] = ..., response_deserializer: Optional[Any] = ...):
        ...
    
    def stream_unary(self, method, request_serializer: Optional[Any] = ..., response_deserializer: Optional[Any] = ...):
        ...
    
    def stream_stream(self, method, request_serializer: Optional[Any] = ..., response_deserializer: Optional[Any] = ...):
        ...
    
    def _close(self):
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        ...
    
    def close(self):
        ...
    


def intercept_channel(channel, *interceptors):
    ...

