"""
This type stub file was generated by pyright.
"""

import logging
import six
import grpc
from grpc._cython import cygrpc
from typing import Any, Optional

"""Shared implementation."""
_LOGGER = logging.getLogger(__name__)
CYGRPC_CONNECTIVITY_STATE_TO_CHANNEL_CONNECTIVITY = { cygrpc.ConnectivityState.idle: grpc.ChannelConnectivity.IDLE,cygrpc.ConnectivityState.connecting: grpc.ChannelConnectivity.CONNECTING,cygrpc.ConnectivityState.ready: grpc.ChannelConnectivity.READY,cygrpc.ConnectivityState.transient_failure: grpc.ChannelConnectivity.TRANSIENT_FAILURE,cygrpc.ConnectivityState.shutdown: grpc.ChannelConnectivity.SHUTDOWN }
CYGRPC_STATUS_CODE_TO_STATUS_CODE = { cygrpc.StatusCode.ok: grpc.StatusCode.OK,cygrpc.StatusCode.cancelled: grpc.StatusCode.CANCELLED,cygrpc.StatusCode.unknown: grpc.StatusCode.UNKNOWN,cygrpc.StatusCode.invalid_argument: grpc.StatusCode.INVALID_ARGUMENT,cygrpc.StatusCode.deadline_exceeded: grpc.StatusCode.DEADLINE_EXCEEDED,cygrpc.StatusCode.not_found: grpc.StatusCode.NOT_FOUND,cygrpc.StatusCode.already_exists: grpc.StatusCode.ALREADY_EXISTS,cygrpc.StatusCode.permission_denied: grpc.StatusCode.PERMISSION_DENIED,cygrpc.StatusCode.unauthenticated: grpc.StatusCode.UNAUTHENTICATED,cygrpc.StatusCode.resource_exhausted: grpc.StatusCode.RESOURCE_EXHAUSTED,cygrpc.StatusCode.failed_precondition: grpc.StatusCode.FAILED_PRECONDITION,cygrpc.StatusCode.aborted: grpc.StatusCode.ABORTED,cygrpc.StatusCode.out_of_range: grpc.StatusCode.OUT_OF_RANGE,cygrpc.StatusCode.unimplemented: grpc.StatusCode.UNIMPLEMENTED,cygrpc.StatusCode.internal: grpc.StatusCode.INTERNAL,cygrpc.StatusCode.unavailable: grpc.StatusCode.UNAVAILABLE,cygrpc.StatusCode.data_loss: grpc.StatusCode.DATA_LOSS }
STATUS_CODE_TO_CYGRPC_STATUS_CODE = { grpc_code: cygrpc_code for (cygrpc_code, grpc_code) in six.iteritems(CYGRPC_STATUS_CODE_TO_STATUS_CODE) }
MAXIMUM_WAIT_TIMEOUT = 0.1
def encode(s):
    ...

def decode(b):
    ...

def _transform(message, transformer, exception_message):
    ...

def serialize(message, serializer):
    ...

def deserialize(serialized_message, deserializer):
    ...

def fully_qualified_method(group, method):
    ...

def _wait_once(wait_fn, timeout, spin_cb):
    ...

def wait(wait_fn, wait_complete_fn, timeout: Optional[Any] = ..., spin_cb: Optional[Any] = ...):
    """Blocks waiting for an event without blocking the thread indefinitely.

    See https://github.com/grpc/grpc/issues/19464 for full context. CPython's
    `threading.Event.wait` and `threading.Condition.wait` methods, if invoked
    without a timeout kwarg, may block the calling thread indefinitely. If the
    call is made from the main thread, this means that signal handlers may not
    run for an arbitrarily long period of time.

    This wrapper calls the supplied wait function with an arbitrary short
    timeout to ensure that no signal handler has to wait longer than
    MAXIMUM_WAIT_TIMEOUT before executing.

    Args:
      wait_fn: A callable acceptable a single float-valued kwarg named
        `timeout`. This function is expected to be one of `threading.Event.wait`
        or `threading.Condition.wait`.
      wait_complete_fn: A callable taking no arguments and returning a bool.
        When this function returns true, it indicates that waiting should cease.
      timeout: An optional float-valued number of seconds after which the wait
        should cease.
      spin_cb: An optional Callable taking no arguments and returning nothing.
        This callback will be called on each iteration of the spin. This may be
        used for, e.g. work related to forking.

    Returns:
      True if a timeout was supplied and it was reached. False otherwise.
    """
    ...

