"""
This type stub file was generated by pyright.
"""

import collections
import enum
import logging
import grpc
from typing import Any, Optional

"""Service-side implementation of gRPC Python."""
_LOGGER = logging.getLogger(__name__)
_SHUTDOWN_TAG = 'shutdown'
_REQUEST_CALL_TAG = 'request_call'
_RECEIVE_CLOSE_ON_SERVER_TOKEN = 'receive_close_on_server'
_SEND_INITIAL_METADATA_TOKEN = 'send_initial_metadata'
_RECEIVE_MESSAGE_TOKEN = 'receive_message'
_SEND_MESSAGE_TOKEN = 'send_message'
_SEND_INITIAL_METADATA_AND_SEND_MESSAGE_TOKEN = 'send_initial_metadata * send_message'
_SEND_STATUS_FROM_SERVER_TOKEN = 'send_status_from_server'
_SEND_INITIAL_METADATA_AND_SEND_STATUS_FROM_SERVER_TOKEN = 'send_initial_metadata * send_status_from_server'
_OPEN = 'open'
_CLOSED = 'closed'
_CANCELLED = 'cancelled'
_EMPTY_FLAGS = 0
_DEALLOCATED_SERVER_CHECK_PERIOD_S = 1
_INF_TIMEOUT = 1000000000
def _serialized_request(request_event):
    ...

def _application_code(code):
    ...

def _completion_code(state):
    ...

def _abortion_code(state, code):
    ...

def _details(state):
    ...

class _HandlerCallDetails(collections.namedtuple('_HandlerCallDetails', ('method', 'invocation_metadata')), grpc.HandlerCallDetails):
    ...


class _RPCState(object):
    def __init__(self):
        self.condition = ...
        self.due = ...
        self.request = ...
        self.client = ...
        self.initial_metadata_allowed = ...
        self.compression_algorithm = ...
        self.disable_next_compression = ...
        self.trailing_metadata = ...
        self.code = ...
        self.details = ...
        self.statused = ...
        self.rpc_errors = ...
        self.callbacks = ...
        self.aborted = ...
    


def _raise_rpc_error(state):
    ...

def _possibly_finish_call(state, token):
    ...

def _send_status_from_server(state, token):
    ...

def _get_initial_metadata(state, metadata):
    ...

def _get_initial_metadata_operation(state, metadata):
    ...

def _abort(state, call, code, details):
    ...

def _receive_close_on_server(state):
    ...

def _receive_message(state, call, request_deserializer):
    ...

def _send_initial_metadata(state):
    ...

def _send_message(state, token):
    ...

class _Context(grpc.ServicerContext):
    def __init__(self, rpc_event, state, request_deserializer):
        ...
    
    def is_active(self):
        ...
    
    def time_remaining(self):
        ...
    
    def cancel(self):
        ...
    
    def add_callback(self, callback):
        ...
    
    def disable_next_message_compression(self):
        ...
    
    def invocation_metadata(self):
        ...
    
    def peer(self):
        ...
    
    def peer_identities(self):
        ...
    
    def peer_identity_key(self):
        ...
    
    def auth_context(self):
        ...
    
    def set_compression(self, compression):
        ...
    
    def send_initial_metadata(self, initial_metadata):
        ...
    
    def set_trailing_metadata(self, trailing_metadata):
        ...
    
    def abort(self, code, details):
        ...
    
    def abort_with_status(self, status):
        ...
    
    def set_code(self, code):
        ...
    
    def set_details(self, details):
        ...
    
    def _finalize_state(self):
        ...
    


class _RequestIterator(object):
    def __init__(self, state, call, request_deserializer):
        ...
    
    def _raise_or_start_receive_message(self):
        ...
    
    def _look_for_request(self):
        ...
    
    def _next(self):
        ...
    
    def __iter__(self):
        ...
    
    def __next__(self):
        ...
    
    def next(self):
        ...
    


def _unary_request(rpc_event, state, request_deserializer):
    ...

def _call_behavior(rpc_event, state, behavior, argument, request_deserializer, send_response_callback: Optional[Any] = ...):
    ...

def _take_response_from_response_iterator(rpc_event, state, response_iterator):
    ...

def _serialize_response(rpc_event, state, response, response_serializer):
    ...

def _get_send_message_op_flags_from_state(state):
    ...

def _reset_per_message_state(state):
    ...

def _send_response(rpc_event, state, serialized_response):
    ...

def _status(rpc_event, state, serialized_response):
    ...

def _unary_response_in_pool(rpc_event, state, behavior, argument_thunk, request_deserializer, response_serializer):
    ...

def _stream_response_in_pool(rpc_event, state, behavior, argument_thunk, request_deserializer, response_serializer):
    ...

def _is_rpc_state_active(state):
    ...

def _send_message_callback_to_blocking_iterator_adapter(rpc_event, state, send_response_callback, response_iterator):
    ...

def _select_thread_pool_for_behavior(behavior, default_thread_pool):
    ...

def _handle_unary_unary(rpc_event, state, method_handler, default_thread_pool):
    ...

def _handle_unary_stream(rpc_event, state, method_handler, default_thread_pool):
    ...

def _handle_stream_unary(rpc_event, state, method_handler, default_thread_pool):
    ...

def _handle_stream_stream(rpc_event, state, method_handler, default_thread_pool):
    ...

def _find_method_handler(rpc_event, generic_handlers, interceptor_pipeline):
    ...

def _reject_rpc(rpc_event, status, details):
    ...

def _handle_with_method_handler(rpc_event, method_handler, thread_pool):
    ...

def _handle_call(rpc_event, generic_handlers, interceptor_pipeline, thread_pool, concurrency_exceeded):
    ...

@enum.unique
class _ServerStage(enum.Enum):
    STOPPED = ...
    STARTED = ...
    GRACE = ...


class _ServerState(object):
    def __init__(self, completion_queue, server, generic_handlers, interceptor_pipeline, thread_pool, maximum_concurrent_rpcs):
        self.lock = ...
        self.completion_queue = ...
        self.server = ...
        self.generic_handlers = ...
        self.interceptor_pipeline = ...
        self.thread_pool = ...
        self.stage = ...
        self.termination_event = ...
        self.shutdown_events = ...
        self.maximum_concurrent_rpcs = ...
        self.active_rpc_count = ...
        self.rpc_states = ...
        self.due = ...
        self.server_deallocated = ...
    


def _add_generic_handlers(state, generic_handlers):
    ...

def _add_insecure_port(state, address):
    ...

def _add_secure_port(state, address, server_credentials):
    ...

def _request_call(state):
    ...

def _stop_serving(state):
    ...

def _on_call_completed(state):
    ...

def _process_event_and_continue(state, event):
    ...

def _serve(state):
    ...

def _begin_shutdown_once(state):
    ...

def _stop(state, grace):
    ...

def _start(state):
    ...

def _validate_generic_rpc_handlers(generic_rpc_handlers):
    ...

def _augment_options(base_options, compression):
    ...

class _Server(grpc.Server):
    def __init__(self, thread_pool, generic_handlers, interceptors, options, maximum_concurrent_rpcs, compression):
        ...
    
    def add_generic_rpc_handlers(self, generic_rpc_handlers):
        ...
    
    def add_insecure_port(self, address):
        ...
    
    def add_secure_port(self, address, server_credentials):
        ...
    
    def start(self):
        ...
    
    def wait_for_termination(self, timeout: Optional[Any] = ...):
        ...
    
    def stop(self, grace):
        ...
    
    def __del__(self):
        ...
    


def create_server(thread_pool, generic_rpc_handlers, interceptors, options, maximum_concurrent_rpcs, compression):
    ...

