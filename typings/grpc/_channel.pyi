"""
This type stub file was generated by pyright.
"""

import logging
import os
import threading
import grpc
from grpc import _grpcio_metadata
from grpc._cython import cygrpc
from typing import Any, Optional

"""Invocation-side implementation of gRPC Python."""
_LOGGER = logging.getLogger(__name__)
_USER_AGENT = 'grpc-python/{}'.format(_grpcio_metadata.__version__)
_EMPTY_FLAGS = 0
_DEFAULT_SINGLE_THREADED_UNARY_STREAM = os.getenv("GRPC_SINGLE_THREADED_UNARY_STREAM") is not None
_UNARY_UNARY_INITIAL_DUE = (cygrpc.OperationType.send_initial_metadata, cygrpc.OperationType.send_message, cygrpc.OperationType.send_close_from_client, cygrpc.OperationType.receive_initial_metadata, cygrpc.OperationType.receive_message, cygrpc.OperationType.receive_status_on_client)
_UNARY_STREAM_INITIAL_DUE = (cygrpc.OperationType.send_initial_metadata, cygrpc.OperationType.send_message, cygrpc.OperationType.send_close_from_client, cygrpc.OperationType.receive_initial_metadata, cygrpc.OperationType.receive_status_on_client)
_STREAM_UNARY_INITIAL_DUE = (cygrpc.OperationType.send_initial_metadata, cygrpc.OperationType.receive_initial_metadata, cygrpc.OperationType.receive_message, cygrpc.OperationType.receive_status_on_client)
_STREAM_STREAM_INITIAL_DUE = (cygrpc.OperationType.send_initial_metadata, cygrpc.OperationType.receive_initial_metadata, cygrpc.OperationType.receive_status_on_client)
_CHANNEL_SUBSCRIPTION_CALLBACK_ERROR_LOG_MESSAGE = 'Exception calling channel subscription callback!'
_OK_RENDEZVOUS_REPR_FORMAT = '<{} of RPC that terminated with:\n' '\tstatus = {}\n' '\tdetails = "{}"\n' '>'
_NON_OK_RENDEZVOUS_REPR_FORMAT = '<{} of RPC that terminated with:\n' '\tstatus = {}\n' '\tdetails = "{}"\n' '\tdebug_error_string = "{}"\n' '>'
def _deadline(timeout):
    ...

def _unknown_code_details(unknown_cygrpc_code, details):
    ...

class _RPCState(object):
    def __init__(self, due, initial_metadata, trailing_metadata, code, details):
        self.condition = ...
        self.due = ...
        self.initial_metadata = ...
        self.response = ...
        self.trailing_metadata = ...
        self.code = ...
        self.details = ...
        self.debug_error_string = ...
        self.cancelled = ...
        self.callbacks = ...
        self.fork_epoch = ...
    
    def reset_postfork_child(self):
        self.condition = ...
    


def _abort(state, code, details):
    ...

def _handle_event(event, state, response_deserializer):
    ...

def _event_handler(state, response_deserializer):
    ...

def _consume_request_iterator(request_iterator, state, call, request_serializer, event_handler):
    """Consume a request iterator supplied by the user."""
    ...

def _rpc_state_string(class_name, rpc_state):
    """Calculates error string for RPC."""
    ...

class _InactiveRpcError(grpc.RpcError, grpc.Call, grpc.Future):
    """An RPC error not tied to the execution of a particular RPC.

    The RPC represented by the state object must not be in-progress or
    cancelled.

    Attributes:
      _state: An instance of _RPCState.
    """
    def __init__(self, state):
        ...
    
    def initial_metadata(self):
        ...
    
    def trailing_metadata(self):
        ...
    
    def code(self):
        ...
    
    def details(self):
        ...
    
    def debug_error_string(self):
        ...
    
    def _repr(self):
        ...
    
    def __repr__(self):
        ...
    
    def __str__(self):
        ...
    
    def cancel(self):
        """See grpc.Future.cancel."""
        ...
    
    def cancelled(self):
        """See grpc.Future.cancelled."""
        ...
    
    def running(self):
        """See grpc.Future.running."""
        ...
    
    def done(self):
        """See grpc.Future.done."""
        ...
    
    def result(self, timeout: Optional[Any] = ...):
        """See grpc.Future.result."""
        ...
    
    def exception(self, timeout: Optional[Any] = ...):
        """See grpc.Future.exception."""
        ...
    
    def traceback(self, timeout: Optional[Any] = ...):
        """See grpc.Future.traceback."""
        ...
    
    def add_done_callback(self, fn, timeout: Optional[Any] = ...):
        """See grpc.Future.add_done_callback."""
        ...
    


class _Rendezvous(grpc.RpcError, grpc.RpcContext):
    """An RPC iterator.

    Attributes:
      _state: An instance of _RPCState.
      _call: An instance of SegregatedCall or IntegratedCall.
        In either case, the _call object is expected to have operate, cancel,
        and next_event methods.
      _response_deserializer: A callable taking bytes and return a Python
        object.
      _deadline: A float representing the deadline of the RPC in seconds. Or
        possibly None, to represent an RPC with no deadline at all.
    """
    def __init__(self, state, call, response_deserializer, deadline):
        ...
    
    def is_active(self):
        """See grpc.RpcContext.is_active"""
        ...
    
    def time_remaining(self):
        """See grpc.RpcContext.time_remaining"""
        ...
    
    def cancel(self):
        """See grpc.RpcContext.cancel"""
        ...
    
    def add_callback(self, callback):
        """See grpc.RpcContext.add_callback"""
        ...
    
    def __iter__(self):
        ...
    
    def next(self):
        ...
    
    def __next__(self):
        ...
    
    def _next(self):
        ...
    
    def debug_error_string(self):
        ...
    
    def _repr(self):
        ...
    
    def __repr__(self):
        ...
    
    def __str__(self):
        ...
    
    def __del__(self):
        ...
    


class _SingleThreadedRendezvous(_Rendezvous, grpc.Call):
    """An RPC iterator operating entirely on a single thread.

    The __next__ method of _SingleThreadedRendezvous does not depend on the
    existence of any other thread, including the "channel spin thread".
    However, this means that its interface is entirely synchronous. So this
    class cannot fulfill the grpc.Future interface.
    """
    def initial_metadata(self):
        """See grpc.Call.initial_metadata"""
        ...
    
    def trailing_metadata(self):
        """See grpc.Call.trailing_metadata"""
        ...
    
    def code(self):
        """See grpc.Call.code"""
        ...
    
    def details(self):
        """See grpc.Call.details"""
        ...
    
    def _consume_next_event(self):
        ...
    
    def _next_response(self):
        ...
    
    def _next(self):
        ...
    
    def debug_error_string(self):
        ...
    


class _MultiThreadedRendezvous(_Rendezvous, grpc.Call, grpc.Future):
    """An RPC iterator that depends on a channel spin thread.

    This iterator relies upon a per-channel thread running in the background,
    dequeueing events from the completion queue, and notifying threads waiting
    on the threading.Condition object in the _RPCState object.

    This extra thread allows _MultiThreadedRendezvous to fulfill the grpc.Future interface
    and to mediate a bidirection streaming RPC.
    """
    def initial_metadata(self):
        """See grpc.Call.initial_metadata"""
        ...
    
    def trailing_metadata(self):
        """See grpc.Call.trailing_metadata"""
        ...
    
    def code(self):
        """See grpc.Call.code"""
        ...
    
    def details(self):
        """See grpc.Call.details"""
        ...
    
    def debug_error_string(self):
        ...
    
    def cancelled(self):
        ...
    
    def running(self):
        ...
    
    def done(self):
        ...
    
    def _is_complete(self):
        ...
    
    def result(self, timeout: Optional[Any] = ...):
        """Returns the result of the computation or raises its exception.

        See grpc.Future.result for the full API contract.
        """
        ...
    
    def exception(self, timeout: Optional[Any] = ...):
        """Return the exception raised by the computation.

        See grpc.Future.exception for the full API contract.
        """
        ...
    
    def traceback(self, timeout: Optional[Any] = ...):
        """Access the traceback of the exception raised by the computation.

        See grpc.future.traceback for the full API contract.
        """
        ...
    
    def add_done_callback(self, fn):
        ...
    
    def _next(self):
        ...
    


def _start_unary_request(request, timeout, request_serializer):
    ...

def _end_unary_response_blocking(state, call, with_call, deadline):
    ...

def _stream_unary_invocation_operationses(metadata, initial_metadata_flags):
    ...

def _stream_unary_invocation_operationses_and_tags(metadata, initial_metadata_flags):
    ...

def _determine_deadline(user_deadline):
    ...

class _UnaryUnaryMultiCallable(grpc.UnaryUnaryMultiCallable):
    def __init__(self, channel, managed_call, method, request_serializer, response_deserializer):
        ...
    
    def _prepare(self, request, timeout, metadata, wait_for_ready, compression):
        ...
    
    def _blocking(self, request, timeout, metadata, credentials, wait_for_ready, compression):
        ...
    
    def __call__(self, request, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    
    def with_call(self, request, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    
    def future(self, request, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    


class _SingleThreadedUnaryStreamMultiCallable(grpc.UnaryStreamMultiCallable):
    def __init__(self, channel, method, request_serializer, response_deserializer):
        ...
    
    def __call__(self, request, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    


class _UnaryStreamMultiCallable(grpc.UnaryStreamMultiCallable):
    def __init__(self, channel, managed_call, method, request_serializer, response_deserializer):
        ...
    
    def __call__(self, request, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    


class _StreamUnaryMultiCallable(grpc.StreamUnaryMultiCallable):
    def __init__(self, channel, managed_call, method, request_serializer, response_deserializer):
        ...
    
    def _blocking(self, request_iterator, timeout, metadata, credentials, wait_for_ready, compression):
        ...
    
    def __call__(self, request_iterator, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    
    def with_call(self, request_iterator, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    
    def future(self, request_iterator, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    


class _StreamStreamMultiCallable(grpc.StreamStreamMultiCallable):
    def __init__(self, channel, managed_call, method, request_serializer, response_deserializer):
        ...
    
    def __call__(self, request_iterator, timeout: Optional[Any] = ..., metadata: Optional[Any] = ..., credentials: Optional[Any] = ..., wait_for_ready: Optional[Any] = ..., compression: Optional[Any] = ...):
        ...
    


class _InitialMetadataFlags(int):
    """Stores immutable initial metadata flags"""
    def __new__(cls, value=...):
        ...
    
    def with_wait_for_ready(self, wait_for_ready):
        ...
    


class _ChannelCallState(object):
    def __init__(self, channel):
        self.lock = ...
        self.channel = ...
        self.managed_calls = ...
        self.threading = ...
    
    def reset_postfork_child(self):
        self.managed_calls = ...
    


def _run_channel_spin_thread(state):
    ...

def _channel_managed_call_management(state):
    ...

class _ChannelConnectivityState(object):
    def __init__(self, channel):
        self.lock = ...
        self.channel = ...
        self.polling = ...
        self.connectivity = ...
        self.try_to_connect = ...
        self.callbacks_and_connectivities = ...
        self.delivering = ...
    
    def reset_postfork_child(self):
        self.polling = ...
        self.connectivity = ...
        self.try_to_connect = ...
        self.callbacks_and_connectivities = ...
        self.delivering = ...
    


def _deliveries(state):
    ...

def _deliver(state, initial_connectivity, initial_callbacks):
    ...

def _spawn_delivery(state, callbacks):
    ...

def _poll_connectivity(state, channel, initial_try_to_connect):
    ...

def _subscribe(state, callback, try_to_connect):
    ...

def _unsubscribe(state, callback):
    ...

def _augment_options(base_options, compression):
    ...

def _separate_channel_options(options):
    """Separates core channel options from Python channel options."""
    ...

class Channel(grpc.Channel):
    """A cygrpc.Channel-backed implementation of grpc.Channel."""
    def __init__(self, target, options, credentials, compression):
        """Constructor.

        Args:
          target: The target to which to connect.
          options: Configuration options for the channel.
          credentials: A cygrpc.ChannelCredentials or None.
          compression: An optional value indicating the compression method to be
            used over the lifetime of the channel.
        """
        ...
    
    def _process_python_options(self, python_options):
        """Sets channel attributes according to python-only channel options."""
        ...
    
    def subscribe(self, callback, try_to_connect: Optional[Any] = ...):
        ...
    
    def unsubscribe(self, callback):
        ...
    
    def unary_unary(self, method, request_serializer: Optional[Any] = ..., response_deserializer: Optional[Any] = ...):
        ...
    
    def unary_stream(self, method, request_serializer: Optional[Any] = ..., response_deserializer: Optional[Any] = ...):
        ...
    
    def stream_unary(self, method, request_serializer: Optional[Any] = ..., response_deserializer: Optional[Any] = ...):
        ...
    
    def stream_stream(self, method, request_serializer: Optional[Any] = ..., response_deserializer: Optional[Any] = ...):
        ...
    
    def _unsubscribe_all(self):
        ...
    
    def _close(self):
        ...
    
    def _close_on_fork(self):
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        ...
    
    def close(self):
        ...
    
    def __del__(self):
        ...
    


