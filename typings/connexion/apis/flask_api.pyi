"""
This type stub file was generated by pyright.
"""

import logging
from connexion.apis.abstract import AbstractAPI
from werkzeug.local import LocalProxy
from typing import Any, Optional

logger = logging.getLogger('connexion.apis.flask_api')
class FlaskApi(AbstractAPI):
    def _set_base_path(self, base_path):
        ...
    
    def _set_blueprint(self):
        self.blueprint = ...
    
    def add_openapi_json(self):
        """
        Adds spec json to {base_path}/swagger.json
        or {base_path}/openapi.json (for oas3)
        """
        ...
    
    def add_openapi_yaml(self):
        """
        Adds spec yaml to {base_path}/swagger.yaml
        or {base_path}/openapi.yaml (for oas3)
        """
        ...
    
    def add_swagger_ui(self):
        """
        Adds swagger ui to {base_path}/ui/
        """
        ...
    
    def add_auth_on_not_found(self, security, security_definitions):
        """
        Adds a 404 error handler to authenticate and only expose the 404 status if the security validation pass.
        """
        ...
    
    def _add_operation_internal(self, method, path, operation):
        ...
    
    @property
    def _handlers(self):
        ...
    
    @classmethod
    def get_response(cls, response, mimetype: Optional[Any] = ..., request: Optional[Any] = ...):
        """Gets ConnexionResponse instance for the operation handler
        result. Status Code and Headers for response.  If only body
        data is returned by the endpoint function, then the status
        code will be set to 200 and no headers will be added.

        If the returned object is a flask.Response then it will just
        pass the information needed to recreate it.

        :type response: flask.Response | (flask.Response,) | (flask.Response, int) | (flask.Response, dict) | (flask.Response, int, dict)
        :rtype: ConnexionResponse
        """
        ...
    
    @classmethod
    def _is_framework_response(cls, response):
        """ Return True if provided response is a framework type """
        ...
    
    @classmethod
    def _framework_to_connexion_response(cls, response, mimetype):
        """ Cast framework response class to ConnexionResponse used for schema validation """
        ...
    
    @classmethod
    def _connexion_to_framework_response(cls, response, mimetype, extra_context: Optional[Any] = ...):
        """ Cast ConnexionResponse to framework response class """
        ...
    
    @classmethod
    def _build_response(cls, mimetype, content_type: Optional[Any] = ..., headers: Optional[Any] = ..., status_code: Optional[Any] = ..., data: Optional[Any] = ..., extra_context: Optional[Any] = ...):
        ...
    
    @classmethod
    def _serialize_data(cls, data, mimetype):
        ...
    
    @classmethod
    def get_request(cls, *args, **params):
        """Gets ConnexionRequest instance for the operation handler
        result. Status Code and Headers for response.  If only body
        data is returned by the endpoint function, then the status
        code will be set to 200 and no headers will be added.

        If the returned object is a flask.Response then it will just
        pass the information needed to recreate it.

        :rtype: ConnexionRequest
        """
        ...
    
    @classmethod
    def _set_jsonifier(cls):
        """
        Use Flask specific JSON loader
        """
        ...
    


def _get_context():
    ...

context = LocalProxy(_get_context)
class InternalHandlers(object):
    """
    Flask handlers for internally registered endpoints.
    """
    def __init__(self, base_path, options, specification):
        self.base_path = ...
        self.options = ...
        self.specification = ...
    
    def console_ui_home(self):
        """
        Home page of the OpenAPI Console UI.

        :return:
        """
        ...
    
    def console_ui_static_files(self, filename):
        """
        Servers the static files for the OpenAPI Console UI.

        :param filename: Requested file contents.
        :return:
        """
        ...
    
    def get_json_spec(self):
        ...
    
    def get_yaml_spec(self):
        ...
    
    def _spec_for_prefix(self):
        """
        Modify base_path in the spec based on incoming url
        This fixes problems with reverse proxies changing the path.
        """
        ...
    


