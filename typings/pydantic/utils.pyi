"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Dict, Generator, Iterator, List, Optional, Set, TYPE_CHECKING, Tuple, Type, TypeVar, Union, no_type_check
from .typing import AbstractSetIntStr, AnyType, DictIntStrAny, IntStr, MappingIntStrAny, ReprArgs
from .version import version_info
from inspect import Signature
from .main import BaseConfig, BaseModel
from .fields import ModelField
from .dataclasses import DataclassType

if TYPE_CHECKING:
    ...
__all__ = ('import_string', 'sequence_like', 'validate_field_name', 'lenient_issubclass', 'in_ipython', 'deep_update', 'update_not_none', 'almost_equal_floats', 'get_model', 'to_camel', 'PyObjectStr', 'Representation', 'GetterDict', 'ValueItems', 'version_info')
def import_string(dotted_path: str) -> Any:
    """
    Stolen approximately from django. Import a dotted module path and return the attribute/class designated by the
    last name in the path. Raise ImportError if the import fails.
    """
    ...

def truncate(v: Union[str], *, max_len: int = ...) -> str:
    """
    Truncate a value and add a unicode ellipsis (three dots) to the end if it was too long
    """
    ...

def sequence_like(v: AnyType) -> bool:
    ...

def validate_field_name(bases: List[Type[BaseModel]], field_name: str) -> None:
    """
    Ensure that the field's name does not shadow an existing attribute of the model.
    """
    ...

def lenient_issubclass(cls: Any, class_or_tuple: Union[AnyType, Tuple[AnyType, ...]]) -> bool:
    ...

def in_ipython() -> bool:
    """
    Check whether we're in an ipython environment, including jupyter notebooks.
    """
    ...

KeyType = TypeVar('KeyType')
def deep_update(mapping: Dict[KeyType, Any], updating_mapping: Dict[KeyType, Any]) -> Dict[KeyType, Any]:
    ...

def update_not_none(mapping: Dict[Any, Any], **update: Any) -> None:
    ...

def almost_equal_floats(value_1: float, value_2: float, *, delta: float = ...) -> bool:
    """
    Return True if two floats are almost equal
    """
    ...

def generate_model_signature(init: Callable[..., None], fields: Dict[str, ModelField], config: Type[BaseConfig]) -> Signature:
    """
    Generate signature for model based on its fields
    """
    ...

def get_model(obj: Union[Type[BaseModel], Type[DataclassType]]) -> Type[BaseModel]:
    ...

def to_camel(string: str) -> str:
    ...

class PyObjectStr(str):
    """
    String class where repr doesn't include quotes. Useful with Representation when you want to return a string
    representation of something that valid (or pseudo-valid) python.
    """
    def __repr__(self) -> str:
        ...
    


class Representation:
    """
    Mixin to provide __str__, __repr__, and __pretty__ methods. See #884 for more details.

    __pretty__ is used by [devtools](https://python-devtools.helpmanual.io/) to provide human readable representations
    of objects.
    """
    def __repr_args__(self) -> ReprArgs:
        """
        Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.

        Can either return:
        * name - value pairs, e.g.: `[('foo_name', 'foo'), ('bar_name', ['b', 'a', 'r'])]`
        * or, just values, e.g.: `[(None, 'foo'), (None, ['b', 'a', 'r'])]`
        """
        ...
    
    def __repr_name__(self) -> str:
        """
        Name of the instance's class, used in __repr__.
        """
        ...
    
    def __repr_str__(self, join_str: str) -> str:
        ...
    
    def __pretty__(self, fmt: Callable[[Any], Any], **kwargs: Any) -> Generator[Any, None, None]:
        """
        Used by devtools (https://python-devtools.helpmanual.io/) to provide a human readable representations of objects
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    


class GetterDict(Representation):
    """
    Hack to make object's smell just enough like dicts for validate_model.

    We can't inherit from Mapping[str, Any] because it upsets cython so we have to implement all methods ourselves.
    """
    __slots__ = ...
    def __init__(self, obj: Any):
        ...
    
    def __getitem__(self, key: str) -> Any:
        ...
    
    def get(self, key: Any, default: Any = ...) -> Any:
        ...
    
    def extra_keys(self) -> Set[Any]:
        """
        We don't want to get any other attributes of obj if the model didn't explicitly ask for them
        """
        ...
    
    def keys(self) -> List[Any]:
        """
        Keys of the pseudo dictionary, uses a list not set so order information can be maintained like python
        dictionaries.
        """
        ...
    
    def values(self) -> List[Any]:
        ...
    
    def items(self) -> Iterator[Tuple[str, Any]]:
        ...
    
    def __iter__(self) -> Iterator[str]:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __contains__(self, item: Any) -> bool:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def __repr_args__(self) -> ReprArgs:
        ...
    
    def __repr_name__(self) -> str:
        ...
    


class ValueItems(Representation):
    """
    Class for more convenient calculation of excluded or included fields on values.
    """
    __slots__ = ...
    def __init__(self, value: Any, items: Union[AbstractSetIntStr, MappingIntStrAny]) -> None:
        ...
    
    @no_type_check
    def is_excluded(self, item: Any) -> bool:
        """
        Check if item is fully excluded
        (value considered excluded if self._type is set and item contained in self._items
         or self._type is dict and self._items.get(item) is ...

        :param item: key or index of a value
        """
        ...
    
    @no_type_check
    def is_included(self, item: Any) -> bool:
        """
        Check if value is contained in self._items

        :param item: key or index of value
        """
        ...
    
    @no_type_check
    def for_element(self, e: IntStr) -> Optional[Union[AbstractSetIntStr, MappingIntStrAny]]:
        """
        :param e: key or index of element on value
        :return: raw values for elemet if self._items is dict and contain needed element
        """
        ...
    
    @no_type_check
    def _normalize_indexes(self, items: Union[AbstractSetIntStr, MappingIntStrAny], v_length: int) -> Union[AbstractSetIntStr, DictIntStrAny]:
        """
        :param items: dict or set of indexes which will be normalized
        :param v_length: length of sequence indexes of which will be

        >>> self._normalize_indexes({0, -2, -1}, 4)
        {0, 2, 3}
        >>> self._normalize_indexes({'__all__'}, 4)
        {0, 1, 2, 3}
        """
        ...
    
    def __repr_args__(self) -> ReprArgs:
        ...
    


