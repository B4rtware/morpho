"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, Optional, TYPE_CHECKING, Tuple, Type, Union
from .class_validators import Validator, ValidatorsList
from .error_wrappers import ErrorList
from .types import ModelOrDc
from .typing import AnyType, NoArgAnyCallable, ReprArgs
from .utils import PyObjectStr, Representation
from .main import BaseConfig

class UndefinedType:
    def __repr__(self) -> str:
        ...
    


Undefined = UndefinedType()
if TYPE_CHECKING:
    ValidateReturn = Tuple[Optional[Any], Optional[ErrorList]]
    LocStr = Union[Tuple[Union[int, str], ...], str]
    BoolUndefined = Union[bool, UndefinedType]
class FieldInfo(Representation):
    """
    Captures extra information about a field.
    """
    __slots__ = ...
    def __init__(self, default: Any = ..., **kwargs: Any) -> None:
        self.default = ...
        self.default_factory = ...
        self.alias = ...
        self.alias_priority = ...
        self.title = ...
        self.description = ...
        self.const = ...
        self.gt = ...
        self.ge = ...
        self.lt = ...
        self.le = ...
        self.multiple_of = ...
        self.min_items = ...
        self.max_items = ...
        self.min_length = ...
        self.max_length = ...
        self.regex = ...
        self.extra = ...
    


def Field(default: Any = ..., *, default_factory: Optional[NoArgAnyCallable] = ..., alias: str = ..., title: str = ..., description: str = ..., const: bool = ..., gt: float = ..., ge: float = ..., lt: float = ..., le: float = ..., multiple_of: float = ..., min_items: int = ..., max_items: int = ..., min_length: int = ..., max_length: int = ..., regex: str = ..., **extra: Any) -> Any:
    """
    Used to provide extra information about a field, either for the model schema or complex valiation. Some arguments
    apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``.

    :param default: since this is replacing the fieldâ€™s default, its first argument is used
      to set the default, use ellipsis (``...``) to indicate the field is required
    :param default_factory: callable that will be called when a default value is needed for this field
      If both `default` and `default_factory` are set, an error is raised.
    :param alias: the public name of the field
    :param title: can be any string, used in the schema
    :param description: can be any string, used in the schema
    :param const: this field is required and *must* take it's default value
    :param gt: only applies to numbers, requires the field to be "greater than". The schema
      will have an ``exclusiveMinimum`` validation keyword
    :param ge: only applies to numbers, requires the field to be "greater than or equal to". The
      schema will have a ``minimum`` validation keyword
    :param lt: only applies to numbers, requires the field to be "less than". The schema
      will have an ``exclusiveMaximum`` validation keyword
    :param le: only applies to numbers, requires the field to be "less than or equal to". The
      schema will have a ``maximum`` validation keyword
    :param multiple_of: only applies to numbers, requires the field to be "a multiple of". The
      schema will have a ``multipleOf`` validation keyword
    :param min_length: only applies to strings, requires the field to have a minimum length. The
      schema will have a ``maximum`` validation keyword
    :param max_length: only applies to strings, requires the field to have a maximum length. The
      schema will have a ``maxLength`` validation keyword
    :param regex: only applies to strings, requires the field match agains a regular expression
      pattern string. The schema will have a ``pattern`` validation keyword
    :param **extra: any additional keyword arguments will be added as is to the schema
    """
    ...

def Schema(default: Any, **kwargs: Any) -> Any:
    ...

SHAPE_SINGLETON = 1
SHAPE_LIST = 2
SHAPE_SET = 3
SHAPE_MAPPING = 4
SHAPE_TUPLE = 5
SHAPE_TUPLE_ELLIPSIS = 6
SHAPE_SEQUENCE = 7
SHAPE_FROZENSET = 8
SHAPE_ITERABLE = 9
SHAPE_GENERIC = 10
SHAPE_NAME_LOOKUP = { SHAPE_LIST: 'List[{}]',SHAPE_SET: 'Set[{}]',SHAPE_TUPLE_ELLIPSIS: 'Tuple[{}, ...]',SHAPE_SEQUENCE: 'Sequence[{}]',SHAPE_FROZENSET: 'FrozenSet[{}]',SHAPE_ITERABLE: 'Iterable[{}]' }
class ModelField(Representation):
    __slots__ = ...
    def __init__(self, *, name: str, type_: AnyType, class_validators: Optional[Dict[str, Validator]], model_config: Type[BaseConfig], default: Any = ..., default_factory: Optional[NoArgAnyCallable] = ..., required: BoolUndefined = ..., alias: str = ..., field_info: Optional[FieldInfo] = ...) -> None:
        self.class_validators = ...
        self.model_config = ...
    
    def get_default(self) -> Any:
        ...
    
    @classmethod
    def infer(cls, *, name: str, value: Any, annotation: Any, class_validators: Optional[Dict[str, Validator]], config: Type[BaseConfig]) -> ModelField:
        ...
    
    def set_config(self, config: Type[BaseConfig]) -> None:
        self.model_config = ...
    
    @property
    def alt_alias(self) -> bool:
        ...
    
    def prepare(self) -> None:
        """
        Prepare the field but inspecting self.default, self.type_ etc.

        Note: this method is **not** idempotent (because _type_analysis is not idempotent),
        e.g. calling it it multiple times may modify the field and configure it incorrectly.
        """
        self.validate_always = ...
    
    def _type_analysis(self) -> None:
        self.sub_fields = ...
    
    def _create_sub_type(self, type_: AnyType, name: str, *, for_keys: bool = ...) -> ModelField:
        ...
    
    def populate_validators(self) -> None:
        """
        Prepare self.pre_validators, self.validators, and self.post_validators based on self.type_'s  __get_validators__
        and class validators. This method should be idempotent, e.g. it should be safe to call multiple times
        without mis-configuring the field.
        """
        self.pre_validators = ...
        self.post_validators = ...
        self.pre_validators = ...
        self.post_validators = ...
    
    def validate(self, v: Any, values: Dict[str, Any], *, loc: LocStr, cls: Optional[ModelOrDc] = ...) -> ValidateReturn:
        ...
    
    def _validate_sequence_like(self, v: Any, values: Dict[str, Any], loc: LocStr, cls: Optional[ModelOrDc]) -> ValidateReturn:
        """
        Validate sequence-like containers: lists, tuples, sets and generators
        Note that large if-else blocks are necessary to enable Cython
        optimization, which is why we disable the complexity check above.
        """
        ...
    
    def _validate_iterable(self, v: Any, values: Dict[str, Any], loc: LocStr, cls: Optional[ModelOrDc]) -> ValidateReturn:
        """
        Validate Iterables.

        This intentionally doesn't validate values to allow infinite generators.
        """
        ...
    
    def _validate_tuple(self, v: Any, values: Dict[str, Any], loc: LocStr, cls: Optional[ModelOrDc]) -> ValidateReturn:
        ...
    
    def _validate_mapping(self, v: Any, values: Dict[str, Any], loc: LocStr, cls: Optional[ModelOrDc]) -> ValidateReturn:
        ...
    
    def _validate_singleton(self, v: Any, values: Dict[str, Any], loc: LocStr, cls: Optional[ModelOrDc]) -> ValidateReturn:
        ...
    
    def _apply_validators(self, v: Any, values: Dict[str, Any], loc: LocStr, cls: Optional[ModelOrDc], validators: ValidatorsList) -> ValidateReturn:
        ...
    
    def include_in_schema(self) -> bool:
        """
        False if this is a simple field just allowing None as used in Unions/Optional.
        """
        ...
    
    def is_complex(self) -> bool:
        """
        Whether the field is "complex" eg. env variables should be parsed as JSON.
        """
        ...
    
    def _type_display(self) -> PyObjectStr:
        ...
    
    def __repr_args__(self) -> ReprArgs:
        ...
    


