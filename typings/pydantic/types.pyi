"""
This type stub file was generated by pyright.
"""

import re
from decimal import Decimal
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, TYPE_CHECKING, Type, TypeVar, Union
from uuid import UUID
from .typing import AnyType, CallableGenerator
from .fields import ModelField

__all__ = ['NoneStr', 'NoneBytes', 'StrBytes', 'NoneStrBytes', 'StrictStr', 'ConstrainedBytes', 'conbytes', 'ConstrainedList', 'conlist', 'ConstrainedStr', 'constr', 'PyObject', 'ConstrainedInt', 'conint', 'PositiveInt', 'NegativeInt', 'ConstrainedFloat', 'confloat', 'PositiveFloat', 'NegativeFloat', 'ConstrainedDecimal', 'condecimal', 'UUID1', 'UUID3', 'UUID4', 'UUID5', 'FilePath', 'DirectoryPath', 'Json', 'JsonWrapper', 'SecretStr', 'SecretBytes', 'StrictBool', 'StrictInt', 'StrictFloat', 'PaymentCardNumber', 'ByteSize']
NoneStr = Optional[str]
NoneBytes = Optional[bytes]
StrBytes = Union[str, bytes]
NoneStrBytes = Optional[StrBytes]
OptionalInt = Optional[int]
OptionalIntFloat = Union[OptionalInt, float]
OptionalIntFloatDecimal = Union[OptionalIntFloat, Decimal]
StrIntFloat = Union[str, int, float]
if TYPE_CHECKING:
    ModelOrDc = Type[Union['BaseModel', 'DataclassType']]
class ConstrainedBytes(bytes):
    strip_whitespace = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    


def conbytes(*, strip_whitespace: bool = ..., min_length: int = ..., max_length: int = ...) -> Type[bytes]:
    ...

T = TypeVar('T')
class ConstrainedList(list):
    __origin__ = ...
    __args__: List[Type[T]]
    item_type: Type[T]
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def list_length_validator(cls, v: Optional[List[T]], field: ModelField) -> Optional[List[T]]:
        ...
    


def conlist(item_type: Type[T], *, min_items: int = ..., max_items: int = ...) -> Type[List[T]]:
    ...

class ConstrainedStr(str):
    strip_whitespace = ...
    strict = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: Union[str]) -> Union[str]:
        ...
    


def constr(*, strip_whitespace: bool = ..., strict: bool = ..., min_length: int = ..., max_length: int = ..., curtail_length: int = ..., regex: str = ...) -> Type[str]:
    ...

class StrictStr(ConstrainedStr):
    strict = ...


if TYPE_CHECKING:
    StrictBool = bool
else:
    ...
class PyObject:
    validate_always = ...
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: Any) -> Any:
        ...
    


class ConstrainedNumberMeta(type):
    def __new__(cls, name: str, bases: Any, dct: Dict[str, Any]) -> ConstrainedInt:
        ...
    


class ConstrainedInt(int, metaclass=ConstrainedNumberMeta):
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    


def conint(*, strict: bool = ..., gt: int = ..., ge: int = ..., lt: int = ..., le: int = ..., multiple_of: int = ...) -> Type[int]:
    ...

class PositiveInt(ConstrainedInt):
    gt = ...


class NegativeInt(ConstrainedInt):
    lt = ...


class StrictInt(ConstrainedInt):
    strict = ...


class ConstrainedFloat(float, metaclass=ConstrainedNumberMeta):
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    


def confloat(*, strict: bool = ..., gt: float = ..., ge: float = ..., lt: float = ..., le: float = ..., multiple_of: float = ...) -> Type[float]:
    ...

class PositiveFloat(ConstrainedFloat):
    gt = ...


class NegativeFloat(ConstrainedFloat):
    lt = ...


class StrictFloat(ConstrainedFloat):
    strict = ...


class ConstrainedDecimal(Decimal, metaclass=ConstrainedNumberMeta):
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: Decimal) -> Decimal:
        ...
    


def condecimal(*, gt: Decimal = ..., ge: Decimal = ..., lt: Decimal = ..., le: Decimal = ..., max_digits: int = ..., decimal_places: int = ..., multiple_of: Decimal = ...) -> Type[Decimal]:
    ...

class UUID1(UUID):
    _required_version = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    


class UUID3(UUID1):
    _required_version = ...


class UUID4(UUID1):
    _required_version = ...


class UUID5(UUID1):
    _required_version = ...


class FilePath(Path):
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: Path) -> Path:
        ...
    


class DirectoryPath(Path):
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: Path) -> Path:
        ...
    


class JsonWrapper:
    ...


class JsonMeta(type):
    def __getitem__(self, t: AnyType) -> Type[JsonWrapper]:
        ...
    


class Json(metaclass=JsonMeta):
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    


class SecretStr:
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: Any) -> SecretStr:
        ...
    
    def __init__(self, value: str):
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def display(self) -> str:
        ...
    
    def get_secret_value(self) -> str:
        ...
    


class SecretBytes:
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: Any) -> SecretBytes:
        ...
    
    def __init__(self, value: bytes):
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def display(self) -> str:
        ...
    
    def get_secret_value(self) -> bytes:
        ...
    


class PaymentCardBrand(str, Enum):
    amex = ...
    mastercard = ...
    visa = ...
    other = ...
    def __str__(self) -> str:
        ...
    


class PaymentCardNumber(str):
    """
    Based on: https://en.wikipedia.org/wiki/Payment_card_number
    """
    bin: str
    last4: str
    brand: PaymentCardBrand
    def __init__(self, card_number: str):
        self.bin = ...
        self.last4 = ...
        self.brand = ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @property
    def masked(self) -> str:
        ...
    
    @classmethod
    def validate_digits(cls, card_number: str) -> str:
        ...
    
    @classmethod
    def validate_luhn_check_digit(cls, card_number: str) -> str:
        """
        Based on: https://en.wikipedia.org/wiki/Luhn_algorithm
        """
        ...
    
    @classmethod
    def validate_length_for_brand(cls, card_number: PaymentCardNumber) -> PaymentCardNumber:
        """
        Validate length based on BIN for major brands:
        https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN)
        """
        ...
    
    @staticmethod
    def _get_brand(card_number: str) -> PaymentCardBrand:
        ...
    


BYTE_SIZES = { 'b': 1,'kb': 10 ** 3,'mb': 10 ** 6,'gb': 10 ** 9,'tb': 10 ** 12,'pb': 10 ** 15,'eb': 10 ** 18,'kib': 2 ** 10,'mib': 2 ** 20,'gib': 2 ** 30,'tib': 2 ** 40,'pib': 2 ** 50,'eib': 2 ** 60 }
byte_string_re = re.compile(r'^\s*(\d*\.?\d+)\s*(\w+)?', re.IGNORECASE)
class ByteSize(int):
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, v: StrIntFloat) -> ByteSize:
        ...
    
    def human_readable(self, decimal: bool = ...) -> str:
        ...
    
    def to(self, unit: str) -> float:
        ...
    


