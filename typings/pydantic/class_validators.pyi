"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Dict, Iterable, List, Optional, Set, TYPE_CHECKING, Tuple, Type, Union, overload
from .typing import AnyCallable
from inspect import Signature
from .main import BaseConfig
from .fields import ModelField
from .types import ModelOrDc

class Validator:
    __slots__ = ...
    def __init__(self, func: AnyCallable, pre: bool = ..., each_item: bool = ..., always: bool = ..., check_fields: bool = ..., skip_on_failure: bool = ...):
        self.func = ...
        self.pre = ...
        self.each_item = ...
        self.always = ...
        self.check_fields = ...
        self.skip_on_failure = ...
    


if TYPE_CHECKING:
    ValidatorCallable = Callable[[Optional[ModelOrDc], Any, Dict[str, Any], ModelField, Type[BaseConfig]], Any]
    ValidatorsList = List[ValidatorCallable]
    ValidatorListDict = Dict[str, List[Validator]]
ROOT_KEY = '__root__'
VALIDATOR_CONFIG_KEY = '__validator_config__'
ROOT_VALIDATOR_CONFIG_KEY = '__root_validator_config__'
def validator(*fields: str, pre: bool = ..., each_item: bool = ..., always: bool = ..., check_fields: bool = ..., whole: bool = ..., allow_reuse: bool = ...) -> Callable[[AnyCallable], classmethod]:
    """
    Decorate methods on the class indicating that they should be used to validate fields
    :param fields: which field(s) the method should be called on
    :param pre: whether or not this validator should be called before the standard validators (else after)
    :param each_item: for complex objects (sets, lists etc.) whether to validate individual elements rather than the
      whole object
    :param always: whether this method and other validators should be called even if the value is missing
    :param check_fields: whether to check that the fields actually exist on the model
    :param allow_reuse: whether to track and raise an error if another validator refers to the decorated function
    """
    ...

@overload
def root_validator(_func: AnyCallable) -> classmethod:
    ...

@overload
def root_validator(*, pre: bool = ..., allow_reuse: bool = ..., skip_on_failure: bool = ...) -> Callable[[AnyCallable], classmethod]:
    ...

def root_validator(_func: Optional[AnyCallable] = ..., *, pre: bool = ..., allow_reuse: bool = ..., skip_on_failure: bool = ...) -> Union[classmethod, Callable[[AnyCallable], classmethod]]:
    """
    Decorate methods on a model indicating that they should be used to validate (and perhaps modify) data either
    before or after standard model parsing/validation is performed.
    """
    ...

def _prepare_validator(function: AnyCallable, allow_reuse: bool) -> classmethod:
    """
    Avoid validators with duplicated names since without this, validators can be overwritten silently
    which generally isn't the intended behaviour, don't run in ipython (see #312) or if allow_reuse is False.
    """
    ...

class ValidatorGroup:
    def __init__(self, validators: ValidatorListDict) -> None:
        self.validators = ...
        self.used_validators = ...
    
    def get_validators(self, name: str) -> Optional[Dict[str, Validator]]:
        ...
    
    def check_for_unused(self) -> None:
        ...
    


def extract_validators(namespace: Dict[str, Any]) -> Dict[str, List[Validator]]:
    ...

def extract_root_validators(namespace: Dict[str, Any]) -> Tuple[List[AnyCallable], List[Tuple[bool, AnyCallable]]]:
    ...

def inherit_validators(base_validators: ValidatorListDict, validators: ValidatorListDict) -> ValidatorListDict:
    ...

def make_generic_validator(validator: AnyCallable) -> ValidatorCallable:
    """
    Make a generic function which calls a validator with the right arguments.

    Unfortunately other approaches (eg. return a partial of a function that builds the arguments) is slow,
    hence this laborious way of doing things.

    It's done like this so validators don't all need **kwargs in their signature, eg. any combination of
    the arguments "values", "fields" and/or "config" are permitted.
    """
    ...

def prep_validators(v_funcs: Iterable[AnyCallable]) -> ValidatorsList:
    ...

all_kwargs = 'values', 'field', 'config'
def _generic_validator_cls(validator: AnyCallable, sig: Signature, args: Set[str]) -> ValidatorCallable:
    ...

def _generic_validator_basic(validator: AnyCallable, sig: Signature, args: Set[str]) -> ValidatorCallable:
    ...

def gather_all_validators(type_: ModelOrDc) -> Dict[str, classmethod]:
    ...

